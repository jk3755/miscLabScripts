---
title: "Disaster Recorvery Code"
author: "Jordan S. Kesner"
date: "December 10, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
---
title: "atacPipeline2.0"
author: "JSK"
date: "12/8/2018"
output: html_document
chunk_output_type: console
editor_options: 
  chunk_output_type: console
---

Install libraries
```{r}
## R packages
#install.packages("RCurl")
#install.packages("ggplot2")
#install.packages("stringr")
#install.packages("devtools")
#install.packages("cluster")
#install.packages("seriation")
#install.packages("igraph")
#install.packages("dplyr")
#install.packages("mclust")
#biocLite("affxparser", suppressUpdates = TRUE)
#install.packages("partitions")
#install.packages("gmp")
#devtools::install_github("r-lib/crayon")

## Bioconductor packages
#source("https://bioconductor.org/biocLite.R")
#biocLite("ATACseqQC", suppressUpdates = TRUE)
#biocLite("ChIPpeakAnno", suppressUpdates = TRUE)
#biocLite("MotifDb", suppressUpdates=TRUE)
#biocLite("BSgenome.Hsapiens.UCSC.hg38", suppressUpdates = TRUE)
#biocLite("TxDb.Hsapiens.UCSC.hg38.knownGene", suppressUpdates = TRUE)
#biocLite("phastCons100way.UCSC.hg38", suppressUpdates = TRUE)
#biocLite("MotIV", suppressUpdates = TRUE)
#biocLite("seqLogo", suppressUpdates = TRUE)
#biocLite("PWMEnrich", suppressUpdates = TRUE)
#biocLite("GenomicRanges", suppressUpdates = TRUE)
#biocLite("stringi", suppressUpdates = TRUE)
#biocLite("ensembldb", suppressUpdates = TRUE)
#biocLite("EnsDb.Hsapiens.v86", suppressUpdates = TRUE)
#biocLite("S4Vectors", suppressUpdates = TRUE)
#biocLite("Rsubread", suppressUpdates = TRUE)
#biocLite("Repitools", suppressUpdates = TRUE)
#biocLite("chromoMap", suppressUpdates = TRUE)
```

Load libraries
```{r}
library(ATACseqQC)
library(ggplot2)
library(reshape2)
library(seriation)
library(igraph)
library(dplyr)
library(cluster)
library(mclust)
library(BSgenome.Hsapiens.UCSC.hg38)
library(MotifDb)
library(GenomicRanges)
library(crayon)
library(MotifDb)
library(MotIV)
library(seqLogo)
library(stringr)
library(PWMEnrich)
library(partitions)
library(Repitools)
library(ensembldb)
library(EnsDb.Hsapiens.v86)
library(S4Vectors)
library(ChIPpeakAnno)
library(Rsamtools)
library(chromoMap)
library(Rsubread) # does not work on windows
```

Change dynamic variables here
```{r}
## Reporting mode
## Options = TRUE, FALSE
## Default = TRUE
reporting <- TRUE

## Running mode
## Options = "NORM" or "TEST"
mode <- "TEST"

## Run name
## Very important to set and make unique if doing a new run
## Suggested naming convention is <Cell line>_<WT or mutation info>_<integer specifying experimental replicate, e.g. 01>
run_name <- "H508_WT_01"

## Required parameters
## Make sure to specify these carefully before starting analysis
path_to_parent_dir <- "/home/ubuntu1/atac/h508/wt01/" # Full path to parent directory, including slash at end
bam_base_filename <- "h508_testranges.sorted.bam" # Base filename of bam input file, must be located in /bam
motif_score <- "90%" # Minimum PWM matching score to consider a locus a hit, expressed as percentage
upstream <- 100 # scan signal x bp upstream of motif match
downstream <- 100 # scan signal x bp downstream of motif match
scope <- paste0("chr", c(1:22, "X", "Y")) # Where to look in the genome, default is paste0("chr", c(1:22, "X", "Y")) for wg

## List of gene symbols for genes to be analyzed
## These must be in correct HGNC format
  genes_to_be_analyzed <- c(
                           "TCF7",
                           "MNX1",
                           "POU5F1B",
                           "ESRRA",
                           "CDX2",
                           "HNF4A",
                           "GMEB2",
                           "HOXA3",
                           "OVOL1",
                           "ASCL2",
                           "ZSWIM1",
                           "CBFA2T2"
                           )

  
runPipeline(bam_base_filename, downstream, genes_to_be_analyzed, motif_score, path_to_parent_dir, reporting, run_name, scope, upstream, mode)
  
```




** Completed Functions **
```{r, echo = FALSE}

runPipeline <- function(bam, downstream, genes, score, parentpath, reporting, runname, scope, upstream, mode){
  
#### Step 1 : Prepare workspace and populate variables ####
gc() # clean the workspace memory
## call setVars function to populate the variables and filenames
setVars(parentpath, bam, score, upstream, downstream, scope, genes, runname, reporting)


if(mode == "TEST"){makeTestRanges()
  cat("Running pipeline in testing mode", "\n")}

if(options_list$reporting == TRUE){cat(red$bold("Successfully populated variables and parameters", "\n"))}
#### end ####

  for (item in gene_info[["genes"]]){ # Iterate over all genes in list
    
    if (options_list$reporting == TRUE){cat("Iterating over all input genes", "\n")}
    
    if (item[["haspwm"]] == TRUE){  # Check that the gene has any PWMs from MotifDB
      
      if (options_list$reporting == TRUE){cat("Checking for PWMs", "\n")}
      
      for (motif in names(item[["matrix"]])){ # Iterate over all unique motifs for current gene
        
        if (options_list$reporting == TRUE){cat("Iterating over all unique PWMs", "\n")}
        
        #### Recover object names and filepaths from records list ####
        
        if (options_list$reporting == TRUE){cat("Constructing object names and filepaths", "\n")}
        
        command <- paste0("signal_name <- '", item[["name"]], "_", motif, "_wg_signals", "'")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        
        command <- paste0("signal_path <- '", dir_list[["sigs"]], signal_name, ".RData", "'")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        
        command <- paste0("fp_path <- '", dir_list[["graphs"]], signal_name, ".svg", "'")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        
        if (options_list$reporting == TRUE){cat(signal_name, "\n", signal_path, "\n", fp_path, "\n")}
        
        if (options_list$reporting == TRUE){cat("Checking if signals object exists...", "\n")}
        
        if (fileCheck(signal_path) == FALSE){ # If signal file does not exist on disk, create and save it
          
        if (options_list$reporting == TRUE){cat("Signals object not found on disk, generating...", "\n")}
          
        #### SIGNALS #####
        if(mode == "NORM"){
        assign(signal_name, generateSignal(
                                            reference = reference_parameters,
                                            PWM = item[["matrix"]][[motif]],
                                            name = signal_name,
                                            type = "hg38",
                                            fp_path = fp_path))
        } else if(mode == "TEST"){
          
          assign(signal_name, generateSignal(
                                            reference = reference_parameters,
                                            PWM = item[["matrix"]][[motif]],
                                            name = signal_name,
                                            type = "hg38",
                                            fp_path = fp_path,
                                            sites = testRanges))
          }
        
        if (options_list$reporting == TRUE){cat("Generated signals object assigned to variable name", signal_name, "\n")}
        
        ## Save the signal object to disk
        
        if (options_list$reporting == TRUE){cat("Saving signal object", "\n")}
        
        if (options_list$reporting == TRUE){cat("Saving signals object to disk at filepath: ", signal_path, "\n")}
        
        command <- paste0("save(", signal_name, ", ", "file = signal_path)")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        
        
        #### end ####
        
        

        #### CLEANUP ####
        if (options_list$reporting == TRUE){cat("Clearing workspace and memory", "\n")}
        gc()
        #### end ####
        
        } else { # If the signal file already exists on disk, skip to next operation
        cat("Signal file exists. skipping to next operation...", "\n")} # End signal filecheck
      } # end for (motif in names(item[["matrix"]]))
    } # end if (item[["haspwm"]] == TRUE)
  } # end for (item in gene_info[["genes"]])
} # end runPipeline function

setVars <- function(parent_dir, bam_filename, min_score, upstream, downstream, scope, genes, run_name, reporting){

#### Set directory paths ####
# declare keyed list for storing directories
dir_list <<- list()
# Parent path
dir_list$parent <<- path_to_parent_dir
# bam path
dir_list$bam <<- paste0(path_to_parent_dir, "bam/")
# graphs path
dir_list$graphs <<- paste0(path_to_parent_dir, "graphs_wg/")
# sigs path
dir_list$sigs <<- paste0(path_to_parent_dir, "sigs_wg/")
#### end ####

#### Set reference parameters ####
# declare keyed list for reference parameters
reference_parameters <<- list()
# bam base filename
reference_parameters$bam_base <<- bam_filename
# bam filepath
reference_parameters$bam_filepath <<- as.character(paste0(dir_list$bam, reference_parameters$bam_base))
# bai index filepath
reference_parameters$bai_filepath <<- paste0(reference_parameters$bam_filepath, ".bai")
# reference genome to use
reference_parameters$genome <<- Hsapiens
# scope of analysis
reference_parameters$scope <<- scope
# minimum score for motif matching
reference_parameters$motif_score <<- min_score
# upstream from motif
reference_parameters$upstream <<- upstream
# downstream from motif
reference_parameters$downstream <<- downstream
#
reference_parameters$run_name <<- run_name
#### end ####

#### Set genes and info LHS list DEFAULT OPTION ####
## Declare list for storing gene information
gene_info <<- list()
## transfer gene symbols and number of genes
gene_info$names <<- genes
gene_info$number <<- length(genes)

## iterate over each gene symbol, gather data and store in nested list
for (a in 1:gene_info[["number"]]){
  
  ## use getMotifPWM function to scan MotifDb for gene motifs
  info <- getMotifPWM(gene_info$names[a])
  
  # case 1 : at least one motif found in motifdb (not null)
  if (!is.null(info[[1]])){
    
    ## copy data into nested list
    # copy the gene name
    string <- paste0("'", gene_info[["names"]][[a]], "'")
    command <- paste0("gene_info$genes$", gene_info[["names"]][[a]],"$name", " <<- ", string)
    eval(parse(text = command))
    # set found in MotifDb to true
    string <- paste0("'", "TRUE", "'")
    command <- paste0("gene_info$genes$", gene_info[["names"]][[a]],"$haspwm", " <<- ", string)
    eval(parse(text = command))
    # set number of unique motifs found in MotifDb
    string <- paste0("'", length(info), "'")
    command <- paste0("gene_info$genes$", gene_info[["names"]][[a]],"$motifs", " <<- ", string)
    eval(parse(text = command))
    
    ## copy the unique motifs to gene list
    # generate names for keys in main gene_info list
    motifs <- c()
    for (b in 1:length(info)){
      motifs[b] <- paste0("motif", b)
      }
    
    # copy the motif matrices to the gene_info list
    for (c in 1:length(info))
      {
      # copy the name of the current motif (motif1, motif2, etc)
      string <- motifs[c]
      # name of variable that holds the current motif matrix
      string2 <- "info[[c]]"
      # construct command
      command <- paste0("gene_info$genes$", gene_info[["names"]][[a]],"$matrix$", string, " <<- ", string2)
      # run the command as code
      eval(parse(text = command, keep.source = getOption("keep.source")))
      }
    }
  # case 2 : no motifs found in motifdb for current gene (null)
  if (is.null(info[[1]]))
    {
    ## copy data into nested list
    # copy the gene name
    string <- paste0("'", gene_info[["names"]][[a]], "'")
    command <- paste0("gene_info$genes$", gene_info[["names"]][[a]],"$name", " <<- ", string)
    eval(parse(text = command))
    # set found in MotifDb to true
    string <- paste0("'", "FALSE", "'")
    command <- paste0("gene_info$genes$", gene_info[["names"]][[a]],"$haspwm", " <<- ", string)
    eval(parse(text = command))
    # set number of unique motifs found in MotifDb
    string <- paste0("'", 0, "'")
    command <- paste0("gene_info$genes$", gene_info[["names"]][[a]],"$motifs", " <<- ", string)
    eval(parse(text = command))
    }
  }
#### end ####

#### Set optional parameters ####
# declare keyed list for storing optional params
options_list <<- list()
options_list$reporting <<- reporting
#### end ####
}# end setVars() function

getMotifPWM <- function(symbol)
{
  
  #### Reporting ####
  cat(black$bold(bgWhite("getMotifPWM current input argument:",
                         (red$bold(symbol)),
                         "\n"
                       )))
  #### end ####
  
  #### Query MotifDb ####
  # Define string to return only Hsapiens motifs
  organism_rows = grep('Hsapiens', values(MotifDb)$organism, ignore.case = TRUE)
  # Define string for given gene
  gene_symbol_rows = grep(symbol, values(MotifDb)$geneSymbol, ignore.case = TRUE)
  # Get indices for the intersection of gene and organism
  human_gene_rows = intersect(gene_symbol_rows, organism_rows)
  # Pull the PWMs
  # need to make it a list to use unique() function to remove duplicate entries
  gene_motifs <- as.list(MotifDb[human_gene_rows])
  # Get unique motifs
  unique_gene_motifs <- unique(gene_motifs)
  # Get number of motifs
  number_unique_gene_motifs <- length(unique_gene_motifs)
  #### end ####
  
  #### Reporting ####
  # total motifs found
  cat(black$bold(bgWhite("Number of motifs found in database:",
                         (red$bold(length(gene_motifs))),
                         "\n"
                       )))

  # unique motifs found
  cat(black$bold(bgWhite("Number of unique motifs:",
                       (red$bold(length(unique_gene_motifs))),
                       "\n",
                       "\n"
                       )))
  #### end ####
  
  #### Return PWM ####
  # Make a vector containing all the motifs
  unique_gene_motifs.vector <- c()
  for (a in 1:number_unique_gene_motifs) {
    unique_gene_motifs.vector[a] <- unique_gene_motifs[a]
  }
  
  # return the vector
  return(unique_gene_motifs.vector)
  #### end ####
  
  } # end getMotifPWM function

fileCheck <- function(filepath){
  ## Check for file at argument path
  ## Return TRUE if file exists
  ## Return FALSE if file does not exist
  cat("Checking for file...","\n")
  if (file.exists(filepath) == TRUE){ 
      cat(white$bgBlue$bold("File exists at path:", red(filepath), "\n"))
      return(TRUE)
    }else if (file.exists(filepath) == FALSE){
      cat(white$bgBlue$bold("File not found at path:", red(filepath), "\n"))
      return(FALSE)
    } # end if statement
  } # end fileCheck function

generateSignal <- function(reference, PWM, name, type, fp_path, sites){
  svg(filename = fp_path) # set the SVG options
  
    if(is.null(sites)){
    cat("Generating signal object", "\n")
    signal <- factorFootprints(
                              bamfiles = reference$bam_filepath, # bam file input
                              index = reference$bai_filepath, # bai index input
                              pfm = PWM, # PWM input
                              genome = reference$genome, # reference genome
                              min.score = reference$motif_score, # minimum motif matching score
                              seqlev = reference$scope, # scope of analysis
                              upstream = reference$upstream, # bp upstream of motif to analyze
                              downstream = reference$downstream # bp downstream of motif to analyze
    )} else {
      cat("Generating TEST signal object", "\n")
      signal <- factorFootprints(
                              bamfiles = reference$bam_filepath, # bam file input
                              index = reference$bai_filepath, # bai index input
                              pfm = PWM, # PWM input
                              genome = reference$genome, # reference genome
                              min.score = reference$motif_score, # minimum motif matching score
                              seqlev = reference$scope, # scope of analysis
                              upstream = reference$upstream, # bp upstream of motif to analyze
                              downstream = reference$downstream, # bp downstream of motif to analyze
                              bindingSites = sites)}
  

  ## Close the plot
  dev.off()
  return(signal)
} # end generateSignal function



pwm2pfm <- function(pfm, name="motif"){
    if(!all(round(colSums(pfm), digits=4)==1)){
      return(NULL)
    }
    new("pfm", mat=as.matrix(pfm), name=name)
    }

makeProfile <- function(sites, PWM, type){
  
  anchor <- c("cut site")
  pfm <- PWM  
  min.score <- motif_score
  bindingSites <- sites
  seqlev <- scope
  bamfiles <- bampath
  index <- baipath

      stopifnot(is(bindingSites, "GRanges"))
      stopifnot(all(!is.na(seqlengths(bindingSites))))
      stopifnot(length(bindingSites)>1)
      stopifnot(length(bindingSites$score)==length(bindingSites))
      mt <- bindingSites
      mt$userdefined <- TRUE
  
  wid <- ncol(pfm)
  seqlevels(mt) <- seqlev
  seqinfo(mt) <- Seqinfo(seqlev, seqlengths = seqlengths(mt))
  
  ## read in bam file with input seqlev specified by users
  which <- as(seqinfo(mt), "GRanges")
  param <- ScanBamParam(which=which)
  if(anchor=="cut site"){
    bamIn <- mapply(function(.b, .i) readGAlignments(.b, .i, param = param), 
                    bamfiles, index, SIMPLIFY = FALSE)
  }else{
    bamIn <- mapply(function(.b, .i) readGAlignmentPairs(.b, .i, param = param), 
                    bamfiles, index, SIMPLIFY = FALSE)
  }
  
  ##
  bamIn <- lapply(bamIn, as, Class = "GRanges")
  if(!is(bamIn, "GRangesList")) bamIn <- GRangesList(bamIn)
  bamIn <- unlist(bamIn)
  seqlevelsStyle(bamIn) <- seqlevelsStyle(genome)
  if(anchor=="cut site"){
    ## keep 5'end as cutting sites
    bamIn <- promoters(bamIn, upstream=0, downstream=1)
  }else{
    ## keep fragment center
    bamIn <- reCenterPeaks(bamIn, width=1)
  }
  
  ##
  libSize <- length(bamIn)
  coverageSize <- sum(as.numeric(width(reduce(bamIn, ignore.strand=TRUE))))
  libFactor <- libSize / coverageSize
  
  
  ## split into positive strand and negative strand
  bamIn <- split(bamIn, strand(bamIn))
 
  
  ## get coverage
  cvglist <- sapply(bamIn, coverage)
  cvglist <- cvglist[c("+", "-")]
  cvglist <- lapply(cvglist, function(.ele)
    .ele[names(.ele) %in% seqlev])
  
  ## coverage of mt, must be filtered, otherwise too much
  cvgSum <- cvglist[["+"]] + cvglist[["-"]]
  mt.s <- split(mt, seqnames(mt))
  seqlev <- intersect(names(cvgSum), names(mt.s))
  cvgSum <- cvgSum[seqlev]
  mt.s <- mt.s[seqlev]
  
  ## too much if use upstream and downstream, just use 3*wid maybe better.
  mt.s.ext <- promoters(mt.s, upstream=wid, downstream=wid+wid)
  stopifnot(all(lengths(mt.s.ext)==lengths(mt.s)))
  mt.v <- Views(cvgSum, mt.s.ext)
  mt.s <- mt.s[viewSums(mt.v)>0] 
  mt <- unlist(mt.s)
  mt.ids <- promoters(reCenterPeaks(mt, width=1),
                      upstream=upstream+floor(wid/2),
                      downstream=downstream+ceiling(wid/2)+1)
  mt.ids <- paste0(as.character(seqnames(mt.ids)), ":", start(mt.ids), "-", end(mt.ids))
  sigs <- featureAlignedSignal(cvglists=cvglist,
                              feature.gr=reCenterPeaks(mt, width=1),
                              upstream=upstream+floor(wid/2),
                              downstream=downstream+ceiling(wid/2),
                              n.tile=upstream+downstream+wid)
  mt <- mt[match(rownames(sigs[[1]]), mt.ids)]
  cor <- lapply(sigs, function(sig){
      sig.colMeans <- colMeans(sig)
      ## calculate correlation of footprinting and binding score
      windows <- slidingWindows(IRanges(1, ncol(sig)), width = wid, step = 1)[[1]]
      # remove the windows with overlaps of motif binding region
      windows <- windows[end(windows)<=upstream | start(windows)>=upstream+wid]
      sig.windowMeans <- viewMeans(Views(sig.colMeans, windows))
      windows.sel <- windows[which.max(sig.windowMeans)][1]
      highest.sig.windows <- 
          rowMeans(sig[, start(windows.sel):end(windows.sel)])
      predictedBindingSiteScore <- mt$score
      if(length(predictedBindingSiteScore) == length(highest.sig.windows)){
        suppressWarnings({
          cor <- cor.test(x = predictedBindingSiteScore, 
                          y = highest.sig.windows, 
                          method = "spearman")
        })
      }else{
        cor <- NA
      }
      cor
  })
  
  ###########################################################
  ## This is where you can insert the shuffled signals ######
  sigs <- lapply(sigs, function(.ele) .ele[mt$userdefined, ])
  ## Make the null model
  if (type == "nullmodel"){
  nums <- nrow(sigs[["+"]])
  cols <- ncol(sigs[["+"]])
  plusshuf <- matrix(data=NA, nrow=nums, ncol=cols)
  minusshuf <- matrix(data=NA, nrow=nums, ncol=cols)
  for (c in 1:nums){
    plusshuf[c,] <- as.double(sample(sigs[["+"]][c,], replace=FALSE))
    minusshuf[c,] <- as.double(sample(sigs[["-"]][c,], replace=FALSE))
  }
  sigs$"+" <- plusshuf
  sigs$"-" <- minusshuf
  }
  ###########################################################
  ###########################################################
  
  mt <- mt[mt$userdefined]
  mt$userdefined <- NULL
  
  ## segmentation the signals
  ## x2 because stranded.
  Profile <- lapply(sigs, function(.ele) colMeans(.ele, na.rm = TRUE)*2/libFactor)
  ## upstream + wid + downstream
  Profile.split <- lapply(Profile, function(.ele){
    list(upstream=.ele[seq.int(upstream)],
         binding=.ele[upstream+seq.int(wid)],
         downstream=.ele[upstream+wid+seq.int(downstream)])
  })
  
  ##
  optimalSegmentation <- function(.ele){
    .l <- length(.ele)
    short_abun <- cumsum(.ele)/seq.int(.l)
    long_abun <- cumsum(rev(.ele))/seq.int(.l)
    long_abun <- rev(long_abun)
    short_abun <- short_abun[-length(short_abun)]
    long_abun <- long_abun[-1]
    ##long_abun should always greater than short_abun
    long_abun <- long_abun - short_abun
    long_abun[long_abun<0] <- 0
    cov_diff <- numeric(length(short_abun))
    for(i in seq_along(.ele)){
      cov_diff_tmp <- .ele
      cov_diff_tmp <- cov_diff_tmp-short_abun[i]
      cov_diff_tmp[-seq.int(i)] <- cov_diff_tmp[-seq.int(i)] - long_abun[i]
      cov_diff[i] <- mean(cov_diff_tmp^2)
    }
    .ids <- which(cov_diff==min(cov_diff, na.rm = TRUE))
    data.frame(pos=.ids, short_abun=short_abun[.ids], long_abun=long_abun[.ids])
  }
  Profile.seg <- lapply(Profile.split, function(.ele){
    ups <- optimalSegmentation(.ele$upstream)
    downs <- optimalSegmentation(rev(.ele$downstream))
    ## find the nearest pair
    .min <- c(max(rbind(ups, downs)), 0, 0)
    for(i in seq.int(nrow(ups))){
      for(j in seq.int(nrow(downs))){
        tmp <- sum(abs(ups[i, -1] - downs[j, -1]))
        if(tmp < .min[1]){
          .min <- c(tmp, i, j)
        }
      }
    }
    c(colMeans(rbind(ups[.min[2], ], downs[.min[3], ])), binding=mean(.ele$binding, na.rm=TRUE))
  })
  
  ##
  Profile.seg <- colMeans(do.call(rbind, Profile.seg))
  Profile.seg[3] <- Profile.seg[2]+Profile.seg[3]
  names(Profile.seg)[2:3] <- c("distal_abun", "proximal_abun")
  
  pwm2pfm <- function(pfm, name="motif"){
  if(!all(round(colSums(pfm), digits=4)==1)){
    return(NULL)
  }
  new("pfm", mat=as.matrix(pfm), name=name)
}
  
  ## Input arguments for calling the plotFootprints function
  args <- list()
  args$Profile <- c(Profile[["+"]], Profile[["-"]])
  args$ylab <- ifelse(anchor=="cut site", "Cut-site probability", "reads density (arbitrary unit)")
  args$Mlen <- wid
  args$motif <- pwm2pfm(pfm)
  args$segmentation <- Profile.seg
  
  if (type == "nullmodel"){
  args$nullplus <- sigs$"+"
  args$nullminus <- sigs$"-"
  }
  
  return(args)
}

generateNullFP <- function(n, t, s, m){
#This script will be used to generate indiviudal null models at predicted motif binding sites across the genome when scanning for TF footprinting from ATAC-seq data. To generate these null models, the current model will need to:
#- Consider the total signal (number of insertions) at each specific ~200 bp locus
#- Use the actul underlying reference sequence of that ~200 bp stretch from the hg38 reference genome
#- Use published or experimentally derived models of Tn5 sequence specific insertion bias
#- For each locus, build a probablistic model of insertion site distributions based on the underlying sequence and Tn5 insertion bias
#- Generate the null model graph by weighted random residstribution of the total observed signal at that site
#- Importantly, the null model must be generated separately for the plus and minus strand, it can then be combined and compared to the combined signal from the reference observed signal at that sequence
#These null models can then be used for a site-by-site comparison of the null model against the observed data to accept or reject the null hypothesis
  
  # declare vector of size n to store average motif signal values
  averages <- c()

  # generate the null models and calculate motif averages
  for (a in 1:n){
    
    # declare the null vector
    null <- c(1:(s))
    
    # randomly distribute the total signal
    # size = the number of values to distribute
    # prob = probability of each site
    # length = length of the generated vector
    null <- c(as.vector(rmultinom(1, size=t, prob=rep(1, length(null)))))
    
    # calculate the average signal in the motif region
    b <- (s - 100 - m) # start of motif
    c <- (s - 100) # end of motif
    avg <- sum(null[b:c])
    avg <- (avg/m)

    # store the values
    averages[a] <- avg
    
    ### plotting
    # make the density plot
    # generate the density distribution
    # adjust can be modified to adjust the kernel estimation bandwidth
    #d <- density(averages, adjust=1, from=0)
    # make the plot
    # main can be specified to make a chart title
    # make the title string
    #title <- paste0("Motif signal means", "\n", "n = ", n, ", input signal = ", t, ", motif size = ", m)
    #plot(d, main=title)
    ## check for uniform distribution with QQ plot
    #qqplot(averages, runif(1000))
    #abline(0,1)

  } # end for (a in 1:n)
  return(averages)
} # end generateNullFP function

makeTestRanges <- function(){
  cat("Creating test ranges object","\n")
  testRanges <<- GRanges(seqnames = c(paste0("chr", c(1:22, "X", "Y"))),
                    ranges = IRanges(start = rep(10000, times = 24), end = rep(10500, times = 24)),
                    strand = c(rep("+", times = 24)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = 24)))}

```


** Unfinished functions **
motifClust
```{r}
motifClust <- function(k, signals, num){
## Returns a vector with k clusters referenced by motif site index

if (num == "NULL"){num_sites <- length(signals[["signal"]][["+"]][,1])}else{num_sites <- num}
num_bp <- length(signals[["signal"]][["+"]][1,]) 
motif_width <- (num_bp - 200) # number of basepairs in the motif (assume 100 up/down stream used)
cat("Number of sites: ", num_sites, "\n", "Number of bp in each site: ", num_bp, "\n", "Width of motif: ", motif_width, "\n")

## Add plus and minus strand signals
if (options_list$reporting == TRUE){cat("Generating signal matrix", "\n")}
plus <- signals[["signal"]][["+"]]
minus <- signals[["signal"]][["-"]]
signal_matrix <- matrix(data = NA, nrow = num_sites, ncol = num_bp)
for (a in 1:num_sites){
  for (b in 1:num_bp){
    signal_matrix[a,b] <- (plus[a,b] + minus[a,b])}}


#### Ward Hierarchical Clustering ####
clustin <- signal_matrix
clustin <- scale(clustin) # standardize variables
d <- dist(clustin, method = "euclidean") # distance matrix
fit <- hclust(d, method="ward.D") 
groups <- cutree(fit, k=k) # cut tree into k clusters
plot(fit, type="c") # display dendogram
rect.hclust(fit, k=k, border="red") # draw dendogram with red borders around the k clusters 
return(groups)
#### end ####

 
Model Based Clustering
 
 fit <- Mclust(clustin)
 plot(fit) # plot results 
 summary(fit) # display the best model

 for (a in 1:num){
   for (b in 1:num){
     
     m1 <- signal[["+"]][a,]
     m2 <- signal[["+"]][b,]
     
     correlations[a,b] <- motifCorr(m1,m2)
     
     
   } # end for (b in 1:100)
 } # end for (a in 1:100)


} # end clusterMotif function

```

test motifClust
```{r}

clu <- motifClust(7, ASCL2_motif1_genome_signals, 1000)

```

motifCorr
```{r}
 motifCorr <- function(motif1, motif2){

   # initialize matrix
   cmatrix <- matrix(data=NA, nrow=3, ncol=length(motif1))
   # add values to matrix
   for (a in 1:length(motif1)){
     cmatrix[1,a] <- c(motif1[a])
     cmatrix[2,a] <- c(motif2[a])
     motif1_total <- sum(motif1)
     motif2_total <- sum(motif2)
     cmatrix[3,a] <- abs(cmatrix[1,a]-cmatrix[2,a])
   } # end for (a in 1:motif)

   diff <- as.integer(sum(cmatrix[3,]))
   total <- motif1_total+motif2_total
   norm <- diff/total
   #cat("sum of differences:", diff, "\n")
   #cat("total signal", total, "\n")
   #cat("normalized", norm, "\n")
   return(diff)
 } # end motifCorr

 correlations<-melt(correlations)
 correlations<-correlations[correlations$value!=0,]

 ggplot(correlations, aes(x = Var2, y = Var1)) +
   geom_raster(aes(fill=value)) +
   scale_fill_gradient(low="grey90", high="red") +
   labs(x="letters", y="LETTERS", title="Matrix") +
   theme_bw() + theme(axis.text.x=NULL,
                      axis.text.y=NULL,
                      plot.title=element_text(size=11))

 set.seed(2)
 o <- seriate(correlations, method="BEA_TSP")

 longData<-melt(correlations)
 longData<-longData[longData$value!=0,]

 #with the same longData then earlier
 longData$Var1 <- factor(longData$Var1, levels=names(unlist(o[[1]][])))
 longData$Var2 <- factor(longData$Var2, levels=names(unlist(o[[2]][])))
 #levels must be names

 ggplot(longData, aes(x = Var2, y = Var1)) +
   geom_raster(aes(fill=value)) +
   scale_fill_gradient(low="grey90", high="red") +
   labs(x="letters", y="LETTERS", title="Matrix") +
   theme_bw() + theme(axis.text.x=element_text(size=9, angle=0, vjust=0.3),
                      axis.text.y=element_text(size=9),
                      plot.title=element_text(size=11))
}
```

Retrieve underlying sequences for all motif sites
```{r}
genome <- Hsapiens
gr <- H508_WT_01_CDX2_motif1_wg_signals[["bindingSites"]]
# subset for a quick run
gr <- gr[1:1000]

## Expand the Granges windows to 200 bp on either side of motif
for (a in 1:length(gr)){
    gr[a]@ranges@start <- as.integer(gr[a]@ranges@start - 200)
    #gr[a]@ranges@width <- as.integer(gr[a]@ranges@width + 400)
    }

# getSeq(ref genome, granges), retrieves sequences associated with the Granges sites
seqs <- getSeq(genome, gr, as.character = TRUE)


```

Generate FP heatmaps
```{r}

generateFPHeatmaps <- function(fullpaths, filenames){
  
  ## Get the number of files in the list
  numfiles <- length(filenames) # Get the number of inputs
  
  ## Iterate over all filenames
  for (a in 4:numfiles){
    
    #### Cleanup memory at each iteration ####
    cat(fullpaths[a])
    gc()
    #### end ####
    
    #### Load the signal object into workspace ####
    insig <- load(fullpaths[a])
    signals <- get(insig)
    
    ## Get the total number of entries in the signals
    num_entries <- length(signals[["signal"]][["+"]][,1]) # number of entries to parse
    ## Get the gene name and motif number index
    curfile <- filenames[a]
    # Get the gene name
    re <- regexpr("(^[A-Z1-9]*)", curfile, perl=TRUE)
    gene <- regmatches(curfile, re)
    # Get the motif index
    re <- regexpr("motif([1-9])_", curfile, perl=TRUE)
    mindex <- regmatches(curfile, re)
    re <- regexpr("[1-9]", mindex, perl=TRUE)
    mindex <- as.integer(regmatches(mindex, re))
    ## get the PWM
    PWM <- getMotifPWM(gene)
    PWM <- PWM[[mindex]]
    ## Width of the motif
    motif_width <- length(PWM[1,])
    numbp <- motif_width + upstream + downstream
    #### end ####
    
    #### Make the calculations matrix and subset to top 1000 ####
    calc_matrix <- matrix(data = NA, num_entries, 4) # matrix to store signal calculations
    colnames(calc_matrix) <- c("index","total","motif","ratio")
  
    ## Perform the matrix calculations
    for (b in 1:num_entries){
      calc_matrix[b,"index"] <- b
      calc_matrix[b,"total"] <- (sum(signals[["signal"]][["+"]][b,]) + sum(signals[["signal"]][["-"]][b,]))
      calc_matrix[b,"motif"] <- (sum(signals[["signal"]][["+"]][b,100:100+motif_width]) + sum(signals[["signal"]][["-"]][b,100:100+motif_width]))
      calc_matrix[b,"ratio"] <- (calc_matrix[b,"motif"] / calc_matrix[b,"total"])
    } # End matrix calculations

    ## Find the top 1000 total signal rows
    # sort the matrix by total signal
    sorted <- calc_matrix[order(calc_matrix[,"total"], decreasing = TRUE),]
    # get index of top 1000
    ind <- sorted[1:1000,"index"]

    ## Get the Granges to make the new FP graph
    gr <- signals[["bindingSites"]][ind]
    #### end ####
    
    #### Construct the filepaths for saving the svg files ####
    ## For FP graph
    savepath_fp <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_fp <- gsub("_wg_", "_top_", savepath_fp)
    savepath_fp <- gsub(".RData", "_fp.svg", savepath_fp)
    ## For heatmap
    savepath_heatmap <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_heatmap <- gsub("_wg_", "_top_", savepath_heatmap)
    savepath_heatmap <- gsub(".RData", "_heatmap.svg", savepath_heatmap)
    ## For FP null
    savepath_fp_null <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_fp_null <- gsub("_wg_", "_top_null_", savepath_fp_null)
    savepath_fp_null <- gsub(".RData", "_fp.svg", savepath_fp_null)
    ## For heatmap null
    savepath_heatmap_null <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_heatmap_null <- gsub("_wg_", "_top_", savepath_heatmap_null)
    savepath_heatmap_null <- gsub(".RData", "_null_heatmap.svg", savepath_heatmap_null)
    #### end ####
    
    #### Make the new graphs ####
    #
    sigs <- list()
    #sigs$signal[["+"]] <- (signals[["signal"]][["+"]][ind,]+signals[["signal"]][["-"]][ind,])
    sigs$signal[["+"]] <- (signals[["signal"]][["+"]][ind,])
    sigs$signal[["-"]] <- (signals[["signal"]][["-"]][ind,])
    
    ## FP graph
    prof <- makeProfile(gr, PWM, "normal")
    
    pwm2pfm <- function(pfm, name="motif"){
    if(!all(round(colSums(pfm), digits=4)==1)){
      return(NULL)
    }
    new("pfm", mat=as.matrix(pfm), name=name)
    }
    PWMin <- pwm2pfm(PWM)
    #
    svg(file = savepath_fp) # set the filepath for saving the svg figure
    ATACseqQC:::plotFootprints(prof$Profile,
                               Mlen=motif_width, motif=PWMin)
    dev.off()
    
    ## Heatmap graph
    svg(file = savepath_heatmap) 
    featureAlignedHeatmap(sigs$signal, 
                      feature.gr=reCenterPeaks(gr,
                                               width=numbp), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=numbp)
    dev.off()
    
    ## FP NULL graph
    prof <- makeProfile(gr, PWM, "nullmodel")
    
    pwm2pfm <- function(pfm, name="motif"){
    if(!all(round(colSums(pfm), digits=4)==1)){
      return(NULL)
    }
    new("pfm", mat=as.matrix(pfm), name=name)
    }
    PWMin <- pwm2pfm(PWM)
    #
    svg(file = savepath_fp_null) # set the filepath for saving the svg figure
    ATACseqQC:::plotFootprints(prof$Profile,
                               Mlen=motif_width, motif=PWMin)
    dev.off()
    
    ## Heatmap NULL graph
    svg(file = savepath_heatmap_null)
    nullsig <- list()
    nullsig[["signal"]][["+"]] <- prof$nullplus
    nullsig[["signal"]][["-"]] <- prof$nullminus
    featureAlignedHeatmap(nullsig$signal, 
                      feature.gr=reCenterPeaks(gr,
                                               width=numbp), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=numbp)
    dev.off()
    
    
    #### end ####
    
  } # end for (a in 1:num){
} # end generateFPHeatmaps function
```

signalScanning
```{r}

#This script will be used to calculate ATAC-seq signals at all human genes from hg38
#it will scan windows including:

#1) total signal in 200 bp region upstream of genes
#2) total signal in 2000 bp region upstream of genes
#3) total signal in 200 bp upstream + gene
#4) total signal in 2000 bp upstream + gene
#5) total signal in gene only

#For each of these categories, it will then rank the genes by total signal

#This script references: https://biodatascience.github.io/compbio/bioc/ranges.html

#Copy the gene database
#### Setup ####
## perform gc
gc()

## Paths of bam, bai, genomic locations file
bam <- "/home/rstudio1/atac/h508/bam/h508_all_dedup.bam"
idx <- "/home/rstudio1/atac/h508/bam/h508_all_dedup.bam.bai"
textfile <- "/home/rstudio1/atac/h508/smad4_entrez_targets.txt"
con <- file(description=textfile, open="r")

## Copy list of ENTREZ target IDS from text file
smad4_targets <- c()
for (i in 1:7897){
  smad4_targets[i] <- scan(file=con, nlines=1, quiet=TRUE)
  
}
#### end ####

#### Copy info from ensembl database to make GRanges object ####
# copy the database and gene info
edb <- EnsDb.Hsapiens.v86
g <- genes(edb)
rm(edb)
# subset to only the standard chromosomes
g <- keepStandardChromosomes(g, pruning.mode="coarse")
#### end ####

#### Subset the granges object for specific targets ####
targets <- c(which(g@elementMetadata@listData[["entrezid"]] %in% smad4_targets))
g_smad4 <- g
# this metadata column is required to make the annot object
g_smad4@elementMetadata$id <- g_smad4@elementMetadata@listData[["gene_name"]]
#### end ####

#### initialize the modified granges objects ####
g_smad4_200up <- g_smad4
g_smad4_2000up <- g_smad4
g_smad4_200up_gene <- g_smad4
g_smad4_2000up_gene <- g_smad4
#### end ####

#### make the modified granges objects ####
for (a in 1:length(g_smad4)){
  
  ### change positive strand entries
  if (g_smad4[a]@strand@values == "+"){
    
    ### 200 bp upstream only
    g_smad4_200up[a]@ranges@start <- as.integer(g_smad4_200up[a]@ranges@start - 200)
    g_smad4_200up[a]@ranges@width <- as.integer(200)
    
    ### 2000 bp upstream only
    g_smad4_2000up[a]@ranges@start <- as.integer(g_smad4_2000up[a]@ranges@start - 2000)
    g_smad4_2000up[a]@ranges@width <- as.integer(2000)
    
    ### 200 bp upstream and gene
    g_smad4_200up_gene[a]@ranges@start <- as.integer(g_smad4_200up_gene[a]@ranges@start - 200)
    g_smad4_200up_gene[a]@ranges@width <- as.integer(g_smad4_200up_gene[a]@ranges@width + 200)
    
    ### 2000 bp upstream and gene
    g_smad4_2000up_gene[a]@ranges@start <- as.integer(g_smad4_2000up[a]@ranges@start - 2000)
    g_smad4_2000up_gene[a]@ranges@width <- as.integer(g_smad4_2000up_gene[a]@ranges@width + 2000)
    
  }
  ### change negative strand entries
  if (g_smad4[a]@strand@values == "-"){
    
    ### 200 bp upstream only
    g_smad4_200up[a]@ranges@start <- as.integer(g_smad4_200up[a]@ranges@start + g_smad4_200up[a]@ranges@width)
    g_smad4_200up[a]@ranges@width <- as.integer(200)
    
    ### 2000 bp upstream only
    g_smad4_2000up[a]@ranges@start <- as.integer(g_smad4_2000up[a]@ranges@start + g_smad4_2000up[a]@ranges@width)
    g_smad4_2000up[a]@ranges@width <- as.integer(2000)
    
    ### 200 bp upstream and gene
    g_smad4_200up_gene[a]@ranges@width <- as.integer(g_smad4_200up_gene[a]@ranges@width + 200)
    
    ### 2000 bp upstream and gene
    g_smad4_2000up_gene[a]@ranges@width <- as.integer(g_smad4_2000up_gene[a]@ranges@width + 2000)
  }
}
#### end ####

#### trim out of bounds ranges ####
## use GenomicRanges:::get_out_of_bound_index to find out of bounds ranges

idx <- GenomicRanges:::get_out_of_bound_index(g_smad4)
if (length(idx) != 0L)
    g_smad4 <- g_smad4[-idx]


idx <- GenomicRanges:::get_out_of_bound_index(g_smad4_200up)
if (length(idx) != 0L)
    g_smad4_200up <- g_smad4_200up[-idx]


idx <- GenomicRanges:::get_out_of_bound_index(g_smad4_2000up)
if (length(idx) != 0L)
    g_smad4_2000up <- g_smad4_2000up[-idx]


idx <- GenomicRanges:::get_out_of_bound_index(g_smad4_200up_gene)
if (length(idx) != 0L)
    g_smad4_200up_gene <- g_smad4_200up_gene[-idx]


idx <- GenomicRanges:::get_out_of_bound_index(g_smad4_2000up_gene)
if (length(idx) != 0L)
    g_smad4_2000up_gene <- g_smad4_2000up_gene[-idx]
#### end ####

#### workspace cleanup ####
close.connection(con=con)
#rm(g, i, smad4_targets, targets, textfile)
#### end ####


annot_gene <- createAnnotationFile(g_smad4)
annot_200up <- createAnnotationFile(g_smad4_200up)
annot_2000up <- createAnnotationFile(g_smad4_2000up)
annot_gene_200up <- createAnnotationFile(g_smad4_200up_gene)
annot_gene_2000up <- createAnnotationFile(g_smad4_2000up_gene)

## workspace cleanup
rm(g_smad4, g_smad4_2000up, g_smad4_200up, g_smad4_2000up_gene, g_smad4_200up_gene)


# run featureCounts
counts_gene <- featureCounts(
                        files=bam,
                        isPairedEnd=TRUE,
                        nthreads=8,
                        annot.ext=annot_gene)

counts_200up <- featureCounts(
                        files=bam,
                        isPairedEnd=TRUE,
                        nthreads=8,
                        annot.ext=annot_200up)

counts_2000up <- featureCounts(
                        files=bam,
                        isPairedEnd=TRUE,
                        nthreads=8,
                        annot.ext=annot_2000up)

counts_gene_200up <- featureCounts(
                        files=bam,
                        isPairedEnd=TRUE,
                        nthreads=8,
                        annot.ext=annot_gene_200up)

counts_gene_2000up <- featureCounts(
                        files=bam,
                        isPairedEnd=TRUE,
                        nthreads=8,
                        annot.ext=annot_gene_2000up)

### workspace cleanup
rm(annot_2000up, annot_200up, annot_gene, annot_gene_2000up, annot_gene_200up, a, bam, idx)



### quantiles
qnt_gene <- quantile(counts_gene[["counts"]])
qnt_200up <- quantile(counts_200up[["counts"]])
qnt_2000up <- quantile(counts_2000up[["counts"]])
qnt_gene_200up <- quantile(counts_gene_200up[["counts"]])
qnt_gene_2000up <- quantile(counts_gene_2000up[["counts"]])
###


### make basic plots
plot.default(x=counts_gene[["counts"]], y=NULL, ylab="READS GENE")
plot.default(x=counts_200up[["counts"]], y=NULL, ylab="READS 200UP")
plot.default(x=counts_2000up[["counts"]], y=NULL, ylab="READS 2000UP")
plot.default(x=counts_gene_200up[["counts"]], y=NULL, ylab="READS GENE AND 200UP")
plot.default(x=counts_gene_2000up[["counts"]], y=NULL, ylab="READS GENE AND 2000UP")
###



## copy the total signal to a matrix
signal_matrix <- matrix(data = NA, 56271, 5)
# apply column names to signal matrix
colnames(signal_matrix) <- c("gene", "200up", "2000up", "gene+200up", "gene+2000up")
# apply rownames to matrix
rownames(signal_matrix) <- c(counts_gene[["annotation"]][["GeneID"]])

# copy signal to matrix
for (c in 1:56271){
  signal_matrix[[c,"gene"]] <- as.integer(counts_gene[["counts"]][c])
  signal_matrix[[c,"200up"]] <- as.integer(counts_200up[["counts"]][c])
  signal_matrix[[c,"2000up"]] <- as.integer(counts_2000up[["counts"]][c])
  signal_matrix[[c,"gene+200up"]] <- as.integer(counts_gene_200up[["counts"]][c])
  signal_matrix[[c,"gene+2000up"]] <- as.integer(counts_gene_2000up[["counts"]][c])
}


df <- data.frame(
  "gene"=signal_matrix[,1],
  "200up"=signal_matrix[,2],
  "2000up"=signal_matrix[,3],
  "gene_200up"=signal_matrix[,4],
  "gene_2000up"=signal_matrix[,5]
  )



options(scipen=999)  # turn-off scientific notation like 1e+48


# Scatterplot
theme_set(theme_bw())  # pre-set the bw theme.
g <- ggplot(df, aes(gene, X200up))
g + geom_jitter(width = .5, size=1) +
  labs(y="200 bp upstream", 
       x="gene", 
       title="Read counts gene v 200 bp upstream")


# Scatterplot
theme_set(theme_bw())  # pre-set the bw theme.
g <- ggplot(df, aes(gene, X2000up))
g + geom_jitter(width = .5, size=1) +
  labs(y="2000 bp upstream", 
       x="gene", 
       title="Read counts gene v 2000 bp upstream")




```

plotFootprints
```{r}
plotFootprints <- function (Profile, Mlen = 0,
                            xlab = "Dist. to motif (bp)",
                            ylab = "Cut-site probability",
                            legTitle, xlim, ylim,
                            newpage = TRUE, motif, segmentation)
{
  stopifnot(is(motif, "pfm"))
  if(newpage) grid.newpage()

  S <- length(Profile)
  W <- ((S/2) - Mlen)/2
  vp <- plotViewport(margins=c(5.1, 5.1, 4.1, 2.1), name="plotRegion")
  pushViewport(vp)
  if(missing(xlim)){
    xlim <- c(0, S/2+1)
  }
  if(missing(ylim)){
    ylim <- c(0, max(Profile) * 1.12)
  }
  vp1 <- viewport(y=.4, height=.8,
                  xscale=xlim,
                  yscale=ylim,
                  name="footprints")
  pushViewport(vp1)
  grid.lines(x=1:(S/2),
             y=Profile[1:(S/2)],
             default.units="native",
             gp=gpar(lwd = 2, col = "darkblue"))
  grid.lines(x=1:(S/2),
             y=Profile[(S/2 + 1):S],
             default.units="native",
             gp=gpar(lwd = 2, col = "darkred"))
  if(!missing(segmentation)){
    if(length(segmentation)==4){
      ## plot the guide line for the segmentation
      grid.segments(x0=c(0, segmentation[1], W, W+Mlen, S/2-segmentation[1]),
                    x1=c(segmentation[1], W, W+Mlen, S/2-segmentation[1], S/2),
                    y0=c(segmentation[2], segmentation[3], segmentation[4], segmentation[3], segmentation[2]),
                    y1=c(segmentation[2], segmentation[3], segmentation[4], segmentation[3], segmentation[2]),
                    default.units = "native",
                    gp=gpar(lwd =2, col = "red", lty = 2))
    }
  }
  grid.xaxis(at = c(seq(1, W, length.out = 3),
                    W + seq(1, Mlen),
                    W + Mlen + seq(1, W, length.out = 3)),
             label = c(-(W + 1 - seq(1, W + 1, length.out = 3)),
                       rep("", Mlen),
                       seq(0, W, len = 3)))
  grid.yaxis()
  grid.lines(x=c(W, W, 0), y=c(0, max(Profile), ylim[2]),
             default.units="native", gp=gpar(lty=2))
  grid.lines(x=c(W + Mlen + 1, W + Mlen + 1, S/2),
             y=c(0, max(Profile), ylim[2]),
             default.units="native", gp=gpar(lty=2))
  upViewport()
  vp2 <- viewport(y=.9, height=.2,
                  xscale=c(0, S/2+1),
                  name="motif")
  pushViewport(vp2)
  motifStack::plotMotifLogoA(motif)
  upViewport()
  upViewport()
  grid.text(xlab, y=unit(1, 'lines'))
  grid.text(ylab, x=unit(1, 'line'), rot = 90)
  if(missing(legTitle)){
    legvp <- viewport(x=unit(1, "npc")-convertX(unit(1, "lines"), unitTo="npc"),
                      y=unit(1, "npc")-convertY(unit(1, "lines"), unitTo="npc"),
                      width=convertX(unit(14, "lines"), unitTo="npc"),
                      height=convertY(unit(3, "lines"), unitTo="npc"),
                      just=c("right", "top"), name="legendWraper")
    pushViewport(legvp)
    grid.legend(labels=c("For. strand", "Rev. strand"),
                gp=gpar(lwd=2, lty=1, col=c("darkblue", "darkred")))
    upViewport()
  } else {
    grid.text(legTitle,
              y=unit(1, "npc")-convertY(unit(1, "lines"), unitTo="npc"),
              gp=gpar(cex=1.2, fontface="bold"))
  }
  return(invisible())
}
```

generateFPHeatmaps
```{r}

# Input parameter is a chr vector of filepaths for the signal objects to make heatmaps from
# Part of ChIPPeakAnno package
# See for reference: https://www.rdocumentation.org/packages/ChIPpeakAnno/versions/3.6.5/topics/featureAlignedHeatmap

generateFPHeatmaps <- function(siglist){
  
  num <- length(siglist) # Get the number of inputs
  
  for (a in 1:num){
    
    gc() # clean up memory after each iteration
    sigs <- load(siglist[a]) # load the signals file from disk
    
    
    ## Make the filepath for saving the image
    
    
    
    svg(file =) # set the filepath for saving the svg figure
    
    ## Make the heatmap
    featureAlignedHeatmap(
                      # Calculated signals
                      sigs$signal,
                      # Pass the binding sites
                      # reCenterPeaks reset the center of the binding sites list
                      feature.gr=reCenterPeaks(sigs$bindingSites,
                                               width=200+width(sigs$bindingSites[1])),
                      # Column from the metadata for showing annotations on right side of map
                      annoMcols="score",
                      # What to use for sorting the rows
                      sortBy="score",
                      # Number of tiles to generate, set to width of the binding sites
                      n.tile=ncol(sigs$signal[[1]]))
    
    # Turn off the svg()
    dev.off()
    
  } # end for (a in 1:num){
} # end generateFPHeatmaps function

```

chromHeatmap
```{r}
#Reference: https://cran.r-project.org/web/packages/chromoMap/vignettes/chromoMap.html#installation
#This script will plot ATACseq aligned reads as a heatmap across visual representations of the chromosomes
#Input data must be in dataframe format with following columns:
#name - (type character) names of the elements for mapping, eg. gene names like "TP53"" or "NANOG"
#chrom - (type character) the chromosome name for the gene. It should be provided in format as "chr1","chr2","chrX",or "chrMT". Incorrect format can produce errors
#start - (type numeric) - the starting position of the element
#Heatmaps require these additional columns:
#data - (type numeric or integer) the primary data e.g. counts
#secondData - (type) secondary data for heatmap-double.

# Create a dataframe for H508 gene counts that can be used by chromoMap
bamfile <- "/home/rstudio2/atac/h508/bam/h508_all_dedup.bam" # input bamfile
dataset <- "H508" # name of dataset
edb <- EnsDb.Hsapiens.v86 # get the gene database
g <- genes(edb) # extract the genes
g <- keepStandardChromosomes(g, pruning.mode="coarse") # subset to only the standard chromosomes
num <- length(g) # get number of items
g@elementMetadata$id <- g@elementMetadata@listData[["symbol"]] # this metadata column is required to make the annot object
annot_gene <- createAnnotationFile(g) # create annotation file
# count the number of alignments in each gene
counts_gene <- featureCounts(
                        files=bamfile,
                        isPairedEnd=TRUE,
                        nthreads=8,
                        annot.ext=annot_gene)
h508_gene_atac_counts <- data.frame(
  name = counts_gene[["annotation"]][["GeneID"]],
  chrom = paste0("chr",counts_gene[["annotation"]][["Chr"]]),
  start = counts_gene[["annotation"]][["Start"]],
  data = counts_gene[["counts"]])
colnames(h508_gene_atac_counts)[colnames(h508_gene_atac_counts)=="X.home.rstudio2.atac.h508.bam.h508_all_dedup.bam"] <- "data" # rename the data column
h508_gene_atac_counts <- subset(h508_gene_atac_counts, !grepl(";", h508_gene_atac_counts$chrom)) # remove any entries that have more than one value in the chrom column (by matching to the ;)
row.names(h508_gene_atac_counts) <- NULL # drop the rownames to revert to index
rm(annot_gene, counts_gene, edb, g, bamfile, dataset, num) # cleanup the workspace


# Make the plots
# Annotation plots
chromoMap(h508_gene_atac_counts,type = "annotation") # show annotations of all 
chromoMap(h508_gene_atac_counts, type ="heatmap-single", HeatColRange = c("blue","white","red"))

# Annotation map of gene with at least 1 insertion, save to file
notzero <- subset(h508_gene_atac_counts, !grepl("0", h508_gene_atac_counts$data)) # remove entries with 0 counts
nz_anno_map <- chromoMap(notzero,type = "annotation") # show annotations of genes with at least 1 count
chromoMapToHTML(nz_anno_map,
                title = "ATACseq H508 WT Annotations",
                file = "ATACseq_H508_WT_01_Anno.html",
                dir = "C:/Users/Jordan/Desktop",
                desc = "Annotated set of genes having at least one Tn5 insertion in WT H508")


# Signal heatmap, save to file
h508_gene_atac_counts_map <- chromoMap(h508_gene_atac_counts, type = "heatmap-single", HeatColRange = c("blue", "white", "red")) 
chromoMapToHTML(h508_gene_atac_counts_map,
                title = "ATACseq H508 WT Heatmap",
                file = "ATACseq_H508_WT_01_Heat.html",
                dir = "C:/Users/Jordan/Desktop",
                desc = "Heatmap of Tn5 insertion in WT H508")




# Customizing the plot parameters
chromoMap(pancandata$data1,type = "annotation",dim = c(450,400)) # to resize
chromoMap(pancandata$data2,type = "heatmap-double",align = "vertical") # change orientation
chromoMap(pancandata$data1,chCol = "blue",chBorder = "blue") # change colors
chromoMap(pancandata$data1,chCol = "white",chBorder = "green") # change border style
chromoMap(pancandata$data1,annoColor = "pink") # change annotation color
chromoMap(pancandata$data1,textCol = "green") # change text color
chromoMap(pancandata$data1,bgBorder  = "#FF5733") # border
chromoMap(pancandata$data2,type="heatmap-double",bgCol  = "black") # background color
# Changing heat map colors
chromoMap(pancandata$data2,type="heatmap-double",HeatColRange = c("red","yellow","green")) # three color values are: minimum, medium, maximum values

## Saving plots to an HTML file
#use a variable to store your chromoMap
chmap = chromoMap(h508_gene_atac_counts,type = "heatmap-single", HeatColRange = c("red","yellow","green"))
#pass this to the function
chromoMapToHTML(chmap,file = "myfile.html",dir = "C:/Users/Jordan/Desktop")
#pass a title 
chromoMapToHTML(chmap,title = "Expression profile Comparison in normal vs tumor",file = "myfile.html",dir = "C:/Users/Jordan/Desktop")
#pass a description
my_desc = "you can write a paragraph to describe your plot"
chromoMapToHTML(chmap,title = "Expression profile Comparison in normal vs tumor",description = my_desc)
#open document after save
chromoMapToHTML(chmap,title = "Expression profile Comparison in normal vs tumor",description = my_desc,openAfterSave = TRUE)
```


** Run **
Running the code
```{r echo = FALSE}

runPipeline(dir_list, gene_info, reference_parameters, options_list)

```




Step 1 : load the signals object
```{r}

# load the signals object from disk
#load("~/atac/h508/wt01/sigs/MNX1_motif1_wg_signals.RData")

## the R function apropro() can be used to find objects in the workspace by pattern matching to their name
name <- as.character(apropos("signals")[1])
wgsignals <- get(name)
# remove original
command <- paste0("rm(",name,")")
eval(parse(text = command))
rm(command,name)

# get the number of sites in the whole set
total_sites <- nrow(wgsignals[["signal"]][["+"]])

## sum up the signals
## NOTE - preserve the row names = genomic coordinates
plus <- wgsignals[["signal"]][["+"]]
minus <-  wgsignals[["signal"]][["-"]]
# combine the plus and minus strand signals
total_bp <- length(plus[1,])
combined <- matrix(data=NA,nrow=total_sites,ncol=total_bp)
# combine the signals
for (i in 1:total_sites){combined[i,] <- plus[i,] + minus[i,]}
# xfer row names
rownames(combined) <- rownames(plus)
# cleanup plus and minus
rm(plus,minus)
## get the motif width
motif_width <- total_bp - 200

## for each site, calculate the total signal and motif signal
signal_totals <- c() # total signal
motifsignal_totals <- c() # total signal in the motif
for (i in 1:total_sites){
  signal_totals[i] <- sum(combined[i,])
  motifsignal_totals[i] <- sum(combined[i,100:(100+motif_width)])}

## plot histograms of log10 transformed total signal data
logtot <- log10(signal_totals)
hist(logtot, main = "log10 total site signal")
logmot <- log10(motifsignal_totals)
hist(logmot, main = "log10 total binding motif signal")
rm(logtot,logmot)

## perform quantile analysis and get top 10%
# retrieve the specified quantiles from the total signals
quantiles <- quantile(signal_totals, probs = c(0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1))
# retrieve the indices of the sites in the top 10% of total signal
topten_ind <- which(signal_totals > quantiles[10])
# subset the sites data
topten_sites <- combined[topten_ind,]
# xfer the rownames
rownames(topten_sites) <- rownames(combined[topten_ind,])
# reset the number of inputs
topten_numsites <- nrow(topten_sites)

## recalculate total signal at each site
topten_signal_totals <- signal_totals[topten_ind] # total signal
topten_motifsignal_totals <- motifsignal_totals[topten_ind] # total signal in the motif
# plot log10 histograms
hist(log10(topten_signal_totals))
hist(log10(topten_motifsignal_totals))


## get all the unique values for total signal in the threshold passing sites
## this will be used to compute the null models
unique_signals <- unique(topten_signal_totals)

## generate the set of null models
null_sim <- list()
num <- length(unique_signals)
null_mean <- c()
for (i in 1:num){
  n <- 1000
  t <- unique_signals[i]
  s <- total_bp
  m <- motif_width
  null_sim[[i]] <- generateNullFP(n,t,s,m)
  null_mean[i] <- mean(null_sim[[i]])}

hist(null_mean)
hist(null_sim[[1]])

# generate a density plot of given motif signal means
d <- density(null_sim[[1]], adjust=1, from=0)
    # make the plot
    # main can be specified to make a chart title
    # make the title string
    title <- paste0("Motif signal means", "\n", "n = ", n, ", input signal = ", t, ", motif size = ", m)
    plot(d, main=title)
    
    
## Perform a one-tailed t-test to generate a p-value for each observed motif site
ttest <- list() # list to store the results of the t-tests
pvalue <- c() # vector to store the p-values
tvalue <- c() # vector to store the t-value

for (i in 1:topten_numsites){
  current <- c(topten_sites[i,])
  signal <- c(sum(current))
  # retrieve the appropriate null model
  nullmodel <- null_sim[[which(unique_signals==signal)]]
  # do the t-test
  ttest[[i]] <- t.test(current[100:116], mu=mean(nullmodel), alternative="less", conf.level = 0.95)
  pvalue[i] <- ttest[[i]][["p.value"]]
  tvalue[i] <- ttest[[i]][["statistic"]][["t"]]} 

# get the indices of the sites that are lower than p = 0.05
ppass_ind <- which(pvalue < 0.05)
pvalue_pass <- pvalue[ppass_ind]

# bonferroni correction
bf_ppass_ind <- which(pvalue < (0.05/topten_numsites))
bf_pvalue_pass <- pvalue[bf_ppass_ind]

# benjamin-hochberg correction
# because bonferroni is much more strict, and BH weights the strictness based on the rank of the p-value
bh_pvalues <- p.adjust(pvalue, method="BH")
bh_pass_ind <- (which(bh_pvalues<0.05))

# make histograms
# use xlim to control x axis
hist(pvalue, breaks=20, col="blue", main="p-values")
hist(pvalue_pass)
hist(bf_pvalue_pass)
hist(bh_pass_ind)

```

Step 2 : Find overlaps with the ARACNe network
```{r}
# load the regulons
load("~/atac/coad_regulons.RData")

## choose the correct MR
regulon <- coad_regulons$cdx2

## subset the top10 sites signals to only those that pass the p-value cutoffs
pvalue_pass_signals <- topten_sites[ppass_ind,] # raw p-value
bf_pass_signals <- topten_sites[bf_ppass_ind,] # bf corrected
bh_pass_signals <- topten_sites[bh_pass_ind,] # bh corrected

## match the raw p-value passing sites against ARACNE regulon
# get the rownames from the passed sites
rnames <- rownames(pvalue_pass_signals)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_pvalue_pass <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))


## make Granges for bonferroni corrected
# get the rownames from the passed sites
rnames <- rownames(bf_pass_signals)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_bf_pass <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))


## make Granges for BH correction
# get the rownames from the passed sites
rnames <- rownames(bh_pass_signals)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_bh_pass <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))

## make Granges for the whole topten percent population
# get the rownames from the passed sites
rnames <- rownames(topten_sites)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_topten <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))


## make Granges for the entire sites population
# get the rownames from the passed sites
rnames <- rownames(combined)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_allsites <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))


## Make a Granges for the ARACNe network, set to 2000 bp upstream of genes
#### Copy info from ensembl database to make GRanges object ####
# copy the database and gene info
edb <- EnsDb.Hsapiens.v86
g <- genes(edb)
rm(edb)
# subset to only the standard chromosomes
g <- keepStandardChromosomes(g, pruning.mode="coarse")
#### end ####

# get the list of regulon targets for current regulon
# these are in ENTREZ format
regulon_targets <- regulon[,2]
#### Subset the granges object for specific targets ####
regulon_gr <- c(which(g@elementMetadata@listData[["entrezid"]] %in% regulon_targets))
regulon_gr <- g[regulon_gr]
## modify the start ranges to include 2000 bp upstream region of each gene
for (a in 1:length(regulon_gr)){
  ### change positive strand entries
  if (regulon_gr[a]@strand@values == "+"){
    ### 2000 bp upstream
    regulon_gr[a]@ranges@start <- as.integer(regulon_gr[a]@ranges@start - 2000)
    regulon_gr[a]@ranges@width <- as.integer(regulon_gr[a]@ranges@width + 2000)}
  ### change negative strand entries
  if (regulon_gr[a]@strand@values == "-"){
    ### 2000 bp upstream
    regulon_gr[a]@ranges@width <- as.integer(regulon_gr[a]@ranges@width + 2000)}}

## Use repitools to convert the GRanges to a dataframe
x <- annoGR2DF(regulon_gr)
nchr <- c(paste0("chr",x[,1]))
nstart <- c(x[,2])
nend <- c(x[,3])
le <- length(nchr)
# make the granges
gr_regulon <- GRanges(
                    seqnames = nchr,
                    ranges = IRanges(start = as.numeric(nstart), end = as.numeric(nend)),
                    strand = c(rep("+", times = le)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = le)))

## calculate the overlaps
overlaps <- matrix(data=NA,ncol=3,nrow=5)
colnames(overlaps) <- c("overlaps","total sites","percent")
rownames(overlaps) <- c("pvalue","bf_corrected","bh_corrected","topten","all")
## transfer to matrix
overlaps[1,1] <- length(findOverlaps(gr_pvalue_pass, gr_regulon, ignore.strand=TRUE))
overlaps[2,1] <- length(findOverlaps(gr_bf_pass, gr_regulon, ignore.strand=TRUE))
overlaps[3,1] <- length(findOverlaps(gr_bh_pass, gr_regulon, ignore.strand=TRUE))
overlaps[4,1] <- length(findOverlaps(gr_topten, gr_regulon, ignore.strand=TRUE))
overlaps[5,1] <- length(findOverlaps(gr_allsites, gr_regulon, ignore.strand=TRUE))
# total sites
overlaps[1,2] <- length(gr_pvalue_pass)
overlaps[2,2] <- length(gr_bf_pass)
overlaps[3,2] <- length(gr_bh_pass)
overlaps[4,2] <- length(gr_topten)
overlaps[5,2] <- length(gr_allsites)
# percents
overlaps[1,3] <- (overlaps[1,1]/overlaps[1,2])*100
overlaps[2,3] <- (overlaps[2,1]/overlaps[2,2])*100
overlaps[3,3] <- (overlaps[3,1]/overlaps[3,2])*100
overlaps[4,3] <- (overlaps[4,1]/overlaps[4,2])*100
overlaps[5,3] <- (overlaps[5,1]/overlaps[5,2])*100

```

Step 3 : Generate the new FP graphs and heatmaps
```{r}

## Subset the wg signals object bindingSites
## make profile function only requires binding sites and PWM as input
topten_bindingsites <- wgsignals[["bindingSites"]][topten_ind]
pvalue_pass_bindingsites <- topten_bindingsites[ppass_ind]
bf_pass_bindingsites <- topten_bindingsites[bf_ppass_ind]
bh_pass_bindingsites <- topten_bindingsites[bh_pass_ind]

## params
motif_score <- "90%" # Minimum PWM matching score to consider a locus a hit, expressed as percentage
scope <- paste0("chr", c(1:22, "X", "Y")) # Where to look in the genome, default is paste0("chr", c(1:22, "X", "Y"))
genome <- Hsapiens
bampath <- "/home/ubuntu1/atac/h508/wt01/bam/h508_all_dedup.bam"
baipath <- "/home/ubuntu1/atac/h508/wt01/bam/h508_all_dedup.bam.bai"
upstream <- 100
downstream <- 100

PWM <- getMotifPWM("MNX1")
PWM <- PWM[[1]]

# generate the profiles for all objects
topten_profile <- makeProfile(topten_bindingsites, PWM, type="normal")
pvalue_profile <- makeProfile(pvalue_pass_bindingsites, PWM, type="normal")
bf_profile <- makeProfile(bf_pass_bindingsites, PWM, type="normal")
bh_profile <- makeProfile(bh_pass_bindingsites, PWM, type="normal")

```

call plotFootprints function with profile parameters from makeProfile
```{r}
# Template
# plotFootprints(Profile, Mlen = 0, xlab = "Dist. to motif (bp)", ylab = "Cut-site probability", legTitle, xlim, ylim, newpage = TRUE, motif, segmentation)

    savepath_fp <- "/home/ubuntu1/atac/mnx1_motif1_h508_bh_correction.svg"

    ## FP graph
    PWMin <- pwm2pfm(PWM)
    #
    svg(file = savepath_fp) # set the filepath for saving the svg figure
    ATACseqQC:::plotFootprints(bh_profile$Profile,
                               Mlen=motif_width, motif=PWMin)
    dev.off()
    
    
    ## Subset the wg signals object signals (for making FP graphs)
    ## make profile function only requires binding sites and PWM as input
    plus <- wgsignals[["signal"]][["+"]]
    minus <- wgsignals[["signal"]][["-"]]
    plus <- plus[topten_ind,]
    minus <- minus[topten_ind,]
    plus <- plus[ppass_ind,]
    minus <- minus[ppass_ind,]
    
    pvalue_pass_signals <- list()
    pvalue_pass_signals[["signal"]]$"+" <- plus
    pvalue_pass_signals[["signal"]]$"-" <- minus
    pvalue_pass_signals[["bindingSites"]] <- pvalue_pass_bindingsites
    #topten_signals <- wgsignals[["signals"]][["+"]][[topten_ind,1:208]]
    #pvalue_pass_bindingsites <- topten_bindingsites[ppass_ind]
    #bf_pass_bindingsites <- topten_bindingsites[bf_ppass_ind]
    #bh_pass_bindingsites <- topten_bindingsites[bh_pass_ind]
    
    ## Heatmap graph
    savepath_heatmap <- "/home/ubuntu1/atac/cdx2_heatmap_pvalue.svg"
    svg(file = savepath_heatmap)
    
    featureAlignedHeatmap(pvalue_pass_signals$signal, 
                      feature.gr=reCenterPeaks(pvalue_pass_signals$bindingSites,
                                               width=200+width(pvalue_pass_signals$bindingSites[1])), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=ncol(pvalue_pass_signals$signal[[1]]))
    
    dev.off()
    
    sigs <- wgsignals
    
    featureAlignedHeatmap(sigs$signal, 
                      feature.gr=reCenterPeaks(gr,
                                               width=8), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=8)
    
   



```


---
title: "atacGenerateNullFP"
author: "Jordan S. Kesner"
date: "November 13, 2018"
output: html_document
---

This script will be used to generate indiviudal null models at predicted motif binding sites across the genome when scanning for TF footprinting from ATAC-seq data. To generate these null models, the current model will need to:
- Consider the total signal (number of insertions) at each specific ~200 bp locus
- Use the actul underlying reference sequence of that ~200 bp stretch from the hg38 reference genome
- Use published or experimentally derived models of Tn5 sequence specific insertion bias
- For each locus, build a probablistic model of insertion site distributions based on the underlying sequence and Tn5 insertion bias
- Generate the null model graph by weighted random residstribution of the total observed signal at that site
- Importantly, the null model must be generated separately for the plus and minus strand, it can then be combined and compared to the combined signal from the reference observed signal at that sequence

These null models can then be used for a site-by-site comparison of the null model against the observed data to accept or reject the null hypothesis

Install/load libraries
```{r}
# source("https://bioconductor.org/biocLite.R")
# biocLite("ATACseqQC", suppressUpdates = TRUE)
# biocLite("BSgenome.Hsapiens.UCSC.hg38", suppressUpdates = TRUE)
# biocLite("GenomicRanges", suppressUpdates = TRUE)
# biocLite("stringi", suppressUpdates = TRUE)
# biocLite("GenomicRanges", suppressUpdates = TRUE)
# biocLite("ensembldb", suppressUpdates = TRUE)
# biocLite("EnsDb.Hsapiens.v86", suppressUpdates = TRUE)
# biocLite("S4Vectors", suppressUpdates = TRUE)
# biocLite("Rsubread", suppressUpdates = TRUE)
# biocLite("Repitools", suppressUpdates = TRUE)
# biocLite("affxparser", suppressUpdates = TRUE)
# install.packages("partitions")
library(ATACseqQC)
library(BSgenome.Hsapiens.UCSC.hg38)
library(GenomicRanges)
library(partitions)
library(Repitools)
library(ensembldb)
library(EnsDb.Hsapiens.v86)
library(S4Vectors)
library(ggplot2)
library(MotifDb)
library(ChIPpeakAnno)
library(Rsamtools)
library(GenomicAlignments)
library(crayon)
#library(Rsubread)
```

Retrieve underlying sequences for all motif sites ** work in progress **
```{r}
genome <- Hsapiens
gr <- H508_WT_01_CDX2_motif1_wg_signals[["bindingSites"]]
# subset for a quick run
gr <- gr[1:1000]

## Expand the Granges windows to 200 bp on either side of motif
for (a in 1:length(gr)){
    gr[a]@ranges@start <- as.integer(gr[a]@ranges@start - 200)
    #gr[a]@ranges@width <- as.integer(gr[a]@ranges@width + 400)
    }

# getSeq(ref genome, granges), retrieves sequences associated with the Granges sites
seqs <- getSeq(genome, gr, as.character = TRUE)


```

function generateNullFP
```{r}
generateNullFP <- function(n, t, s, m){
  
  # declare vector of size n to store average motif signal values
  averages <- c()

  # generate the null models and calculate motif averages
  for (a in 1:n){
    
    # declare the null vector
    null <- c(1:(s))
    
    # randomly distribute the total signal
    # size = the number of values to distribute
    # prob = probability of each site
    # length = length of the generated vector
    null <- c(as.vector(rmultinom(1, size=t, prob=rep(1, length(null)))))
    
    # calculate the average signal in the motif region
    b <- (s - 100 - m) # start of motif
    c <- (s - 100) # end of motif
    avg <- sum(null[b:c])
    avg <- (avg/m)

    # store the values
    averages[a] <- avg
    
    ### plotting
    # make the density plot
    # generate the density distribution
    # adjust can be modified to adjust the kernel estimation bandwidth
    #d <- density(averages, adjust=1, from=0)
    # make the plot
    # main can be specified to make a chart title
    # make the title string
    #title <- paste0("Motif signal means", "\n", "n = ", n, ", input signal = ", t, ", motif size = ", m)
    #plot(d, main=title)
    ## check for uniform distribution with QQ plot
    #qqplot(averages, runif(1000))
    #abline(0,1)

  } # end for (a in 1:n)
  return(averages)
} # end generateNullFP function

```

function getMotifPWM
```{r}
getMotifPWM <- function(symbol){
  #### Reporting ####
  cat(black$bold(bgWhite("getMotifPWM current input argument:",
                         (red$bold(symbol)),
                         "\n"
                       )))
  #### end ####
  
  #### Query MotifDb ####
  # Define string to return only Hsapiens motifs
  organism_rows = grep('Hsapiens', values(MotifDb)$organism, ignore.case = TRUE)
  # Define string for given gene
  gene_symbol_rows = grep(symbol, values(MotifDb)$geneSymbol, ignore.case = TRUE)
  # Get indices for the intersection of gene and organism
  human_gene_rows = intersect(gene_symbol_rows, organism_rows)
  # Pull the PWMs
  # need to make it a list to use unique() function to remove duplicate entries
  gene_motifs <- as.list(MotifDb[human_gene_rows])
  # Get unique motifs
  unique_gene_motifs <- unique(gene_motifs)
  # Get number of motifs
  number_unique_gene_motifs <- length(unique_gene_motifs)
  #### end ####
  
  #### Reporting ####
  # total motifs found
  cat(black$bold(bgWhite("Number of motifs found in database:",
                         (red$bold(length(gene_motifs))),
                         "\n"
                       )))
  # unique motifs found
  cat(black$bold(bgWhite("Number of unique motifs:",
                       (red$bold(length(unique_gene_motifs))),
                       "\n",
                       "\n"
                       )))
  #### end ####
  
  #### Return PWM ####
  # Make a vector containing all the motifs
  unique_gene_motifs.vector <- c()
  for (a in 1:number_unique_gene_motifs) {
    unique_gene_motifs.vector[a] <- unique_gene_motifs[a]
  }
  
  # return the vector
  return(unique_gene_motifs.vector)
  #### end ####
  
  } # end getMotifPWM function
```

function makeProfile
```{r}
makeProfile <- function(sites, PWM, type){
  
  anchor <- c("cut site")
  pfm <- PWM  
  min.score <- motif_score
  bindingSites <- sites
  seqlev <- scope
  bamfiles <- bampath
  index <- baipath

      stopifnot(is(bindingSites, "GRanges"))
      stopifnot(all(!is.na(seqlengths(bindingSites))))
      stopifnot(length(bindingSites)>1)
      stopifnot(length(bindingSites$score)==length(bindingSites))
      mt <- bindingSites
      mt$userdefined <- TRUE
  
  wid <- ncol(pfm)
  seqlevels(mt) <- seqlev
  seqinfo(mt) <- Seqinfo(seqlev, seqlengths = seqlengths(mt))
  
  ## read in bam file with input seqlev specified by users
  which <- as(seqinfo(mt), "GRanges")
  param <- ScanBamParam(which=which)
  if(anchor=="cut site"){
    bamIn <- mapply(function(.b, .i) readGAlignments(.b, .i, param = param), 
                    bamfiles, index, SIMPLIFY = FALSE)
  }else{
    bamIn <- mapply(function(.b, .i) readGAlignmentPairs(.b, .i, param = param), 
                    bamfiles, index, SIMPLIFY = FALSE)
  }
  
  ##
  bamIn <- lapply(bamIn, as, Class = "GRanges")
  if(!is(bamIn, "GRangesList")) bamIn <- GRangesList(bamIn)
  bamIn <- unlist(bamIn)
  seqlevelsStyle(bamIn) <- seqlevelsStyle(genome)
  if(anchor=="cut site"){
    ## keep 5'end as cutting sites
    bamIn <- promoters(bamIn, upstream=0, downstream=1)
  }else{
    ## keep fragment center
    bamIn <- reCenterPeaks(bamIn, width=1)
  }
  
  ##
  libSize <- length(bamIn)
  coverageSize <- sum(as.numeric(width(reduce(bamIn, ignore.strand=TRUE))))
  libFactor <- libSize / coverageSize
  
  
  ## split into positive strand and negative strand
  bamIn <- split(bamIn, strand(bamIn))
 
  
  ## get coverage
  cvglist <- sapply(bamIn, coverage)
  cvglist <- cvglist[c("+", "-")]
  cvglist <- lapply(cvglist, function(.ele)
    .ele[names(.ele) %in% seqlev])
  
  ## coverage of mt, must be filtered, otherwise too much
  cvgSum <- cvglist[["+"]] + cvglist[["-"]]
  mt.s <- split(mt, seqnames(mt))
  seqlev <- intersect(names(cvgSum), names(mt.s))
  cvgSum <- cvgSum[seqlev]
  mt.s <- mt.s[seqlev]
  
  ## too much if use upstream and downstream, just use 3*wid maybe better.
  mt.s.ext <- promoters(mt.s, upstream=wid, downstream=wid+wid)
  stopifnot(all(lengths(mt.s.ext)==lengths(mt.s)))
  mt.v <- Views(cvgSum, mt.s.ext)
  mt.s <- mt.s[viewSums(mt.v)>0] 
  mt <- unlist(mt.s)
  mt.ids <- promoters(reCenterPeaks(mt, width=1),
                      upstream=upstream+floor(wid/2),
                      downstream=downstream+ceiling(wid/2)+1)
  mt.ids <- paste0(as.character(seqnames(mt.ids)), ":", start(mt.ids), "-", end(mt.ids))
  sigs <- featureAlignedSignal(cvglists=cvglist,
                              feature.gr=reCenterPeaks(mt, width=1),
                              upstream=upstream+floor(wid/2),
                              downstream=downstream+ceiling(wid/2),
                              n.tile=upstream+downstream+wid)
  mt <- mt[match(rownames(sigs[[1]]), mt.ids)]
  cor <- lapply(sigs, function(sig){
      sig.colMeans <- colMeans(sig)
      ## calculate correlation of footprinting and binding score
      windows <- slidingWindows(IRanges(1, ncol(sig)), width = wid, step = 1)[[1]]
      # remove the windows with overlaps of motif binding region
      windows <- windows[end(windows)<=upstream | start(windows)>=upstream+wid]
      sig.windowMeans <- viewMeans(Views(sig.colMeans, windows))
      windows.sel <- windows[which.max(sig.windowMeans)][1]
      highest.sig.windows <- 
          rowMeans(sig[, start(windows.sel):end(windows.sel)])
      predictedBindingSiteScore <- mt$score
      if(length(predictedBindingSiteScore) == length(highest.sig.windows)){
        suppressWarnings({
          cor <- cor.test(x = predictedBindingSiteScore, 
                          y = highest.sig.windows, 
                          method = "spearman")
        })
      }else{
        cor <- NA
      }
      cor
  })
  
  ###########################################################
  ## This is where you can insert the shuffled signals ######
  sigs <- lapply(sigs, function(.ele) .ele[mt$userdefined, ])
  ## Make the null model
  if (type == "nullmodel"){
  nums <- nrow(sigs[["+"]])
  cols <- ncol(sigs[["+"]])
  plusshuf <- matrix(data=NA, nrow=1000, ncol=cols)
  minusshuf <- matrix(data=NA, nrow=1000, ncol=cols)
  for (c in 1:nums){
    plusshuf[c,] <- as.double(sample(sigs[["+"]][c,], replace=FALSE))
    minusshuf[c,] <- as.double(sample(sigs[["-"]][c,], replace=FALSE))
  }
  sigs$"+" <- plusshuf
  sigs$"-" <- minusshuf
  }
  ###########################################################
  ###########################################################
  
  mt <- mt[mt$userdefined]
  mt$userdefined <- NULL
  
  ## segmentation the signals
  ## x2 because stranded.
  Profile <- lapply(sigs, function(.ele) colMeans(.ele, na.rm = TRUE)*2/libFactor)
  ## upstream + wid + downstream
  Profile.split <- lapply(Profile, function(.ele){
    list(upstream=.ele[seq.int(upstream)],
         binding=.ele[upstream+seq.int(wid)],
         downstream=.ele[upstream+wid+seq.int(downstream)])
  })
  
  ##
  optimalSegmentation <- function(.ele){
    .l <- length(.ele)
    short_abun <- cumsum(.ele)/seq.int(.l)
    long_abun <- cumsum(rev(.ele))/seq.int(.l)
    long_abun <- rev(long_abun)
    short_abun <- short_abun[-length(short_abun)]
    long_abun <- long_abun[-1]
    ##long_abun should always greater than short_abun
    long_abun <- long_abun - short_abun
    long_abun[long_abun<0] <- 0
    cov_diff <- numeric(length(short_abun))
    for(i in seq_along(.ele)){
      cov_diff_tmp <- .ele
      cov_diff_tmp <- cov_diff_tmp-short_abun[i]
      cov_diff_tmp[-seq.int(i)] <- cov_diff_tmp[-seq.int(i)] - long_abun[i]
      cov_diff[i] <- mean(cov_diff_tmp^2)
    }
    .ids <- which(cov_diff==min(cov_diff, na.rm = TRUE))
    data.frame(pos=.ids, short_abun=short_abun[.ids], long_abun=long_abun[.ids])
  }
  Profile.seg <- lapply(Profile.split, function(.ele){
    ups <- optimalSegmentation(.ele$upstream)
    downs <- optimalSegmentation(rev(.ele$downstream))
    ## find the nearest pair
    .min <- c(max(rbind(ups, downs)), 0, 0)
    for(i in seq.int(nrow(ups))){
      for(j in seq.int(nrow(downs))){
        tmp <- sum(abs(ups[i, -1] - downs[j, -1]))
        if(tmp < .min[1]){
          .min <- c(tmp, i, j)
        }
      }
    }
    c(colMeans(rbind(ups[.min[2], ], downs[.min[3], ])), binding=mean(.ele$binding, na.rm=TRUE))
  })
  
  ##
  Profile.seg <- colMeans(do.call(rbind, Profile.seg))
  Profile.seg[3] <- Profile.seg[2]+Profile.seg[3]
  names(Profile.seg)[2:3] <- c("distal_abun", "proximal_abun")
  
  pwm2pfm <- function(pfm, name="motif"){
  if(!all(round(colSums(pfm), digits=4)==1)){
    return(NULL)
  }
  new("pfm", mat=as.matrix(pfm), name=name)
}
  
  ## Input arguments for calling the plotFootprints function
  args <- list()
  args$Profile <- c(Profile[["+"]], Profile[["-"]])
  args$ylab <- ifelse(anchor=="cut site", "Cut-site probability", "reads density (arbitrary unit)")
  args$Mlen <- wid
  args$motif <- pwm2pfm(pfm)
  args$segmentation <- Profile.seg
  
  if (type == "nullmodel"){
  args$nullplus <- sigs$"+"
  args$nullminus <- sigs$"-"
  }
  
  return(args)
}

```


function generateFPHeatmaps
```{r}
generateFPHeatmaps <- function(fullpaths, filenames){
  
  ## Get the number of files in the list
  numfiles <- length(filenames) # Get the number of inputs
  
  ## Iterate over all filenames
  for (a in 4:numfiles){
    
    #### Cleanup memory at each iteration ####
    cat(fullpaths[a])
    gc()
    #### end ####
    
    #### Load the signal object into workspace ####
    insig <- load(fullpaths[a])
    signals <- get(insig)
    
    ## Get the total number of entries in the signals
    num_entries <- length(signals[["signal"]][["+"]][,1]) # number of entries to parse
    ## Get the gene name and motif number index
    curfile <- filenames[a]
    # Get the gene name
    re <- regexpr("(^[A-Z1-9]*)", curfile, perl=TRUE)
    gene <- regmatches(curfile, re)
    # Get the motif index
    re <- regexpr("motif([1-9])_", curfile, perl=TRUE)
    mindex <- regmatches(curfile, re)
    re <- regexpr("[1-9]", mindex, perl=TRUE)
    mindex <- as.integer(regmatches(mindex, re))
    ## get the PWM
    PWM <- getMotifPWM(gene)
    PWM <- PWM[[mindex]]
    ## Width of the motif
    motif_width <- length(PWM[1,])
    numbp <- motif_width + upstream + downstream
    #### end ####
    
    #### Make the calculations matrix and subset to top 1000 ####
    calc_matrix <- matrix(data = NA, num_entries, 4) # matrix to store signal calculations
    colnames(calc_matrix) <- c("index","total","motif","ratio")
  
    ## Perform the matrix calculations
    for (b in 1:num_entries){
      calc_matrix[b,"index"] <- b
      calc_matrix[b,"total"] <- (sum(signals[["signal"]][["+"]][b,]) + sum(signals[["signal"]][["-"]][b,]))
      calc_matrix[b,"motif"] <- (sum(signals[["signal"]][["+"]][b,100:100+motif_width]) + sum(signals[["signal"]][["-"]][b,100:100+motif_width]))
      calc_matrix[b,"ratio"] <- (calc_matrix[b,"motif"] / calc_matrix[b,"total"])
    } # End matrix calculations

    ## Find the top 1000 total signal rows
    # sort the matrix by total signal
    sorted <- calc_matrix[order(calc_matrix[,"total"], decreasing = TRUE),]
    # get index of top 1000
    ind <- sorted[1:1000,"index"]

    ## Get the Granges to make the new FP graph
    gr <- signals[["bindingSites"]][ind]
    #### end ####
    
    #### Construct the filepaths for saving the svg files ####
    ## For FP graph
    savepath_fp <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_fp <- gsub("_wg_", "_top_", savepath_fp)
    savepath_fp <- gsub(".RData", "_fp.svg", savepath_fp)
    ## For heatmap
    savepath_heatmap <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_heatmap <- gsub("_wg_", "_top_", savepath_heatmap)
    savepath_heatmap <- gsub(".RData", "_heatmap.svg", savepath_heatmap)
    ## For FP null
    savepath_fp_null <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_fp_null <- gsub("_wg_", "_top_null_", savepath_fp_null)
    savepath_fp_null <- gsub(".RData", "_fp.svg", savepath_fp_null)
    ## For heatmap null
    savepath_heatmap_null <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_heatmap_null <- gsub("_wg_", "_top_", savepath_heatmap_null)
    savepath_heatmap_null <- gsub(".RData", "_null_heatmap.svg", savepath_heatmap_null)
    #### end ####
    
    #### Make the new graphs ####
    #
    sigs <- list()
    #sigs$signal[["+"]] <- (signals[["signal"]][["+"]][ind,]+signals[["signal"]][["-"]][ind,])
    sigs$signal[["+"]] <- (signals[["signal"]][["+"]][ind,])
    sigs$signal[["-"]] <- (signals[["signal"]][["-"]][ind,])
    
    ## FP graph
    prof <- makeProfile(gr, PWM, "normal")
    
    pwm2pfm <- function(pfm, name="motif"){
    if(!all(round(colSums(pfm), digits=4)==1)){
      return(NULL)
    }
    new("pfm", mat=as.matrix(pfm), name=name)
    }
    PWMin <- pwm2pfm(PWM)
    #
    svg(file = savepath_fp) # set the filepath for saving the svg figure
    ATACseqQC:::plotFootprints(prof$Profile,
                               Mlen=motif_width, motif=PWMin)
    dev.off()
    
    ## Heatmap graph
    svg(file = savepath_heatmap) 
    featureAlignedHeatmap(sigs$signal, 
                      feature.gr=reCenterPeaks(gr,
                                               width=numbp), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=numbp)
    dev.off()
    
    ## FP NULL graph
    prof <- makeProfile(gr, PWM, "nullmodel")
    
    pwm2pfm <- function(pfm, name="motif"){
    if(!all(round(colSums(pfm), digits=4)==1)){
      return(NULL)
    }
    new("pfm", mat=as.matrix(pfm), name=name)
    }
    PWMin <- pwm2pfm(PWM)
    #
    svg(file = savepath_fp_null) # set the filepath for saving the svg figure
    ATACseqQC:::plotFootprints(prof$Profile,
                               Mlen=motif_width, motif=PWMin)
    dev.off()
    
    ## Heatmap NULL graph
    svg(file = savepath_heatmap_null)
    nullsig <- list()
    nullsig[["signal"]][["+"]] <- prof$nullplus
    nullsig[["signal"]][["-"]] <- prof$nullminus
    featureAlignedHeatmap(nullsig$signal, 
                      feature.gr=reCenterPeaks(gr,
                                               width=numbp), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=numbp)
    dev.off()
    
    
    #### end ####
    
  } # end for (a in 1:num){
} # end generateFPHeatmaps function
```

Step 1 : load the signals object
```{r}
# load the signals object from disk
load("~/atac/sigs/CDX2_motif1_wg_signals.RData")

## the R function apropro() can be used to find objects in the workspace by pattern matching to their name
name <- as.character(apropos("signals")[2])
wgsignals <- get(name)
# remove original
command <- paste0("rm(",name,")")
eval(parse(text = command))
rm(command,name)

# get the number of sites in the whole set
total_sites <- nrow(wgsignals[["signal"]][["+"]])

## sum up the signals
## NOTE - preserve the row names = genomic coordinates
plus <- wgsignals[["signal"]][["+"]]
minus <-  wgsignals[["signal"]][["-"]]
# combine the plus and minus strand signals
total_bp <- length(plus[1,])
combined <- matrix(data=NA,nrow=total_sites,ncol=total_bp)
# combine the signals
for (i in 1:total_sites){combined[i,] <- plus[i,] + minus[i,]}
# xfer row names
rownames(combined) <- rownames(plus)
# cleanup plus and minus
rm(plus,minus)
## get the motif width
motif_width <- total_bp - 200

## for each site, calculate the total signal and motif signal
signal_totals <- c() # total signal
motifsignal_totals <- c() # total signal in the motif
for (i in 1:total_sites){
  signal_totals[i] <- sum(combined[i,])
  motifsignal_totals[i] <- sum(combined[i,100:(100+motif_width)])}

## plot histograms of log10 transformed total signal data
logtot <- log10(signal_totals)
hist(logtot, main = "log10 total site signal")
logmot <- log10(motifsignal_totals)
hist(logmot, main = "log10 total binding motif signal")
rm(logtot,logmot)

## perform quantile analysis and get top 10%
# retrieve the specified quantiles from the total signals
quantiles <- quantile(signal_totals, probs = c(0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1))
# retrieve the indices of the sites in the top 10% of total signal
topten_ind <- which(signal_totals > quantiles[10])
# subset the sites data
topten_sites <- combined[topten_ind,]
# xfer the rownames
rownames(topten_sites) <- rownames(combined[topten_ind,])
# reset the number of inputs
topten_numsites <- nrow(topten_sites)

## recalculate total signal at each site
topten_signal_totals <- signal_totals[topten_ind] # total signal
topten_motifsignal_totals <- motifsignal_totals[topten_ind] # total signal in the motif
# plot log10 histograms
hist(log10(topten_signal_totals))
hist(log10(topten_motifsignal_totals))


## get all the unique values for total signal in the threshold passing sites
## this will be used to compute the null models
unique_signals <- unique(topten_signal_totals)

## generate the set of null models
null_sim <- list()
num <- length(unique_signals)
null_mean <- c()
for (i in 1:num){
  n <- 1000
  t <- unique_signals[i]
  s <- total_bp
  m <- motif_width
  null_sim[[i]] <- generateNullFP(n,t,s,m)
  null_mean[i] <- mean(null_sim[[i]])}

hist(null_mean)
hist(null_sim[[1]])

# generate a density plot of given motif signal means
d <- density(null_sim[[1]], adjust=1, from=0)
    # make the plot
    # main can be specified to make a chart title
    # make the title string
    title <- paste0("Motif signal means", "\n", "n = ", n, ", input signal = ", t, ", motif size = ", m)
    plot(d, main=title)
    
    
## Perform a one-tailed t-test to generate a p-value for each observed motif site
ttest <- list() # list to store the results of the t-tests
pvalue <- c() # vector to store the p-values
tvalue <- c() # vector to store the t-value

for (i in 1:topten_numsites){
  current <- c(topten_sites[i,])
  signal <- c(sum(current))
  # retrieve the appropriate null model
  nullmodel <- null_sim[[which(unique_signals==signal)]]
  # do the t-test
  ttest[[i]] <- t.test(current[100:116], mu=mean(nullmodel), alternative="less", conf.level = 0.95)
  pvalue[i] <- ttest[[i]][["p.value"]]
  tvalue[i] <- ttest[[i]][["statistic"]][["t"]]} 

# get the indices of the sites that are lower than p = 0.05
ppass_ind <- which(pvalue < 0.05)
pvalue_pass <- pvalue[ppass_ind]

# bonferroni correction
bf_ppass_ind <- which(pvalue < (0.05/topten_numsites))
bf_pvalue_pass <- pvalue[bf_ppass_ind]

# benjamin-hochberg correction
# because bonferroni is much more strict, and BH weights the strictness based on the rank of the p-value
bh_pvalues <- p.adjust(pvalue, method="BH")
bh_pass_ind <- (which(bh_pvalues<0.05))

# make histograms
# use xlim to control x axis
hist(pvalue, breaks=20, col="blue", main="p-values")
hist(pvalue_pass)
hist(bf_pvalue_pass)
hist(bh_pass_ind)

```

Step 2 : Find overlaps with the ARACNe network
```{r}
# load the regulons
load("~/atac/coad_regulons/coad_regulons.RData")

## choose the correct MR
regulon <- coad_regulons$cdx2

## subset the top10 sites signals to only those that pass the p-value cutoffs
pvalue_pass_signals <- topten_sites[ppass_ind,] # raw p-value
bf_pass_signals <- topten_sites[bf_ppass_ind,] # bf corrected
bh_pass_signals <- topten_sites[bh_pass_ind,] # bh corrected

## match the raw p-value passing sites against ARACNE regulon
# get the rownames from the passed sites
rnames <- rownames(pvalue_pass_signals)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_pvalue_pass <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))


## make Granges for bonferroni corrected
# get the rownames from the passed sites
rnames <- rownames(bf_pass_signals)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_bf_pass <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))


## make Granges for BH correction
# get the rownames from the passed sites
rnames <- rownames(bh_pass_signals)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_bh_pass <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))

## make Granges for the whole topten percent population
# get the rownames from the passed sites
rnames <- rownames(topten_sites)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_topten <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))


## make Granges for the entire sites population
# get the rownames from the passed sites
rnames <- rownames(combined)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_allsites <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))


## Make a Granges for the ARACNe network, set to 2000 bp upstream of genes
#### Copy info from ensembl database to make GRanges object ####
# copy the database and gene info
edb <- EnsDb.Hsapiens.v86
g <- genes(edb)
rm(edb)
# subset to only the standard chromosomes
g <- keepStandardChromosomes(g, pruning.mode="coarse")
#### end ####

# get the list of regulon targets for current regulon
# these are in ENTREZ format
regulon_targets <- regulon[,2]
#### Subset the granges object for specific targets ####
regulon_gr <- c(which(g@elementMetadata@listData[["entrezid"]] %in% regulon_targets))
regulon_gr <- g[regulon_gr]
## modify the start ranges to include 2000 bp upstream region of each gene
for (a in 1:length(regulon_gr)){
  ### change positive strand entries
  if (regulon_gr[a]@strand@values == "+"){
    ### 2000 bp upstream
    regulon_gr[a]@ranges@start <- as.integer(regulon_gr[a]@ranges@start - 2000)
    regulon_gr[a]@ranges@width <- as.integer(regulon_gr[a]@ranges@width + 2000)}
  ### change negative strand entries
  if (regulon_gr[a]@strand@values == "-"){
    ### 2000 bp upstream
    regulon_gr[a]@ranges@width <- as.integer(regulon_gr[a]@ranges@width + 2000)}}

## Use repitools to convert the GRanges to a dataframe
x <- annoGR2DF(regulon_gr)
nchr <- c(paste0("chr",x[,1]))
nstart <- c(x[,2])
nend <- c(x[,3])
le <- length(nchr)
# make the granges
gr_regulon <- GRanges(
                    seqnames = nchr,
                    ranges = IRanges(start = as.numeric(nstart), end = as.numeric(nend)),
                    strand = c(rep("+", times = le)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = le)))

## calculate the overlaps
overlaps <- matrix(data=NA,ncol=3,nrow=5)
colnames(overlaps) <- c("overlaps","total sites","percent")
rownames(overlaps) <- c("pvalue","bf_corrected","bh_corrected","topten","all")
## transfer to matrix
overlaps[1,1] <- length(findOverlaps(gr_pvalue_pass, gr_regulon, ignore.strand=TRUE))
overlaps[2,1] <- length(findOverlaps(gr_bf_pass, gr_regulon, ignore.strand=TRUE))
overlaps[3,1] <- length(findOverlaps(gr_bh_pass, gr_regulon, ignore.strand=TRUE))
overlaps[4,1] <- length(findOverlaps(gr_topten, gr_regulon, ignore.strand=TRUE))
overlaps[5,1] <- length(findOverlaps(gr_allsites, gr_regulon, ignore.strand=TRUE))
# total sites
overlaps[1,2] <- length(gr_pvalue_pass)
overlaps[2,2] <- length(gr_bf_pass)
overlaps[3,2] <- length(gr_bh_pass)
overlaps[4,2] <- length(gr_topten)
overlaps[5,2] <- length(gr_allsites)
# percents
overlaps[1,3] <- (overlaps[1,1]/overlaps[1,2])*100
overlaps[2,3] <- (overlaps[2,1]/overlaps[2,2])*100
overlaps[3,3] <- (overlaps[3,1]/overlaps[3,2])*100
overlaps[4,3] <- (overlaps[4,1]/overlaps[4,2])*100
overlaps[5,3] <- (overlaps[5,1]/overlaps[5,2])*100

```


Step 3 : Generate the new FP graphs and heatmaps
```{r}

## Subset the wg signals object bindingSites
## make profile function only requires binding sites and PWM as input
topten_bindingsites <- wgsignals[["bindingSites"]][topten_ind]
pvalue_pass_bindingsites <- topten_bindingsites[ppass_ind]
bf_pass_bindingsites <- topten_bindingsites[bf_ppass_ind]
bh_pass_bindingsites <- topten_bindingsites[bh_pass_ind]

## params
motif_score <- "90%" # Minimum PWM matching score to consider a locus a hit, expressed as percentage
scope <- paste0("chr", c(1:22, "X", "Y")) # Where to look in the genome, default is paste0("chr", c(1:22, "X", "Y"))
genome <- Hsapiens
("~/atac/sigs/CDX2_motif1_wg_signals.RData")
bampath <- "~/atac/bam/h508_all_dedup.bam"
baipath <- "~/atac/bam/h508_all_dedup.bam.bai"
upstream <- 100
downstream <- 100

PWM <- getMotifPWM("CDX2")
PWM <- PWM[[1]]

# generate the profile
profile <- makeProfile(pvalue_pass_bindingsites, PWM, type="normal")

```

call plotFootprints function with profile parameters from makeProfile
```{r}

```


Make a single heatmap
```{r}

featureAlignedHeatmap(signal$signal, 
                      feature.gr=reCenterPeaks(signal$bindingSites,
                                               width=200+width(signal$bindingSites[1])), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=ncol(signal$signal[[1]]))

```


```


---
title: "atacFPHeatMaps"
author: "Jordan S. Kesner"
date: "November 10, 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

Install/load packages
```{r}
library(ATACseqQC)
library(BSgenome.Hsapiens.UCSC.hg38)
library(MotifDb)
library(ChIPpeakAnno)
library(Rsamtools)
library(GenomicAlignments)
library(crayon)
```

Input filepaths and parameters
```{r}
# specify the parent directory sigs
parentpath <- "/home/rstudio2/atac/ls1034/sigs/"
filenames <- list.files(parentpath)
fullpaths <- c(paste0(parentpath,filenames))
line <- "ls1034"

## params
motif_score <- "90%" # Minimum PWM matching score to consider a locus a hit, expressed as percentage
scope <- paste0("chr", c(1:22, "X", "Y")) # Where to look in the genome, default is paste0("chr", c(1:22, "X", "Y"))
genome <- Hsapiens
bampath <- "/home/rstudio2/atac/ls1034/bam/ls1034_all_dedup.bam"
baipath <- "/home/rstudio2/atac/ls1034/bam/ls1034_all_dedup.bam.bai"
upstream <- 100
downstream <- 100

```

getMotifPWM function
```{r}
getMotifPWM <- function(symbol){
  #### Reporting ####
  cat(black$bold(bgWhite("getMotifPWM current input argument:",
                         (red$bold(symbol)),
                         "\n"
                       )))
  #### end ####
  
  #### Query MotifDb ####
  # Define string to return only Hsapiens motifs
  organism_rows = grep('Hsapiens', values(MotifDb)$organism, ignore.case = TRUE)
  # Define string for given gene
  gene_symbol_rows = grep(symbol, values(MotifDb)$geneSymbol, ignore.case = TRUE)
  # Get indices for the intersection of gene and organism
  human_gene_rows = intersect(gene_symbol_rows, organism_rows)
  # Pull the PWMs
  # need to make it a list to use unique() function to remove duplicate entries
  gene_motifs <- as.list(MotifDb[human_gene_rows])
  # Get unique motifs
  unique_gene_motifs <- unique(gene_motifs)
  # Get number of motifs
  number_unique_gene_motifs <- length(unique_gene_motifs)
  #### end ####
  
  #### Reporting ####
  # total motifs found
  cat(black$bold(bgWhite("Number of motifs found in database:",
                         (red$bold(length(gene_motifs))),
                         "\n"
                       )))
  # unique motifs found
  cat(black$bold(bgWhite("Number of unique motifs:",
                       (red$bold(length(unique_gene_motifs))),
                       "\n",
                       "\n"
                       )))
  #### end ####
  
  #### Return PWM ####
  # Make a vector containing all the motifs
  unique_gene_motifs.vector <- c()
  for (a in 1:number_unique_gene_motifs) {
    unique_gene_motifs.vector[a] <- unique_gene_motifs[a]
  }
  
  # return the vector
  return(unique_gene_motifs.vector)
  #### end ####
  
  } # end getMotifPWM function
```

Generate the **Profile** to provide plotFootprints
```{r}

makeProfile <- function(sites, PWM, type){
  
  anchor <- c("cut site")
  pfm <- PWM  
  min.score <- motif_score
  bindingSites <- sites
  seqlev <- scope
  bamfiles <- bampath
  index <- baipath

      stopifnot(is(bindingSites, "GRanges"))
      stopifnot(all(!is.na(seqlengths(bindingSites))))
      stopifnot(length(bindingSites)>1)
      stopifnot(length(bindingSites$score)==length(bindingSites))
      mt <- bindingSites
      mt$userdefined <- TRUE
  
  wid <- ncol(pfm)
  seqlevels(mt) <- seqlev
  seqinfo(mt) <- Seqinfo(seqlev, seqlengths = seqlengths(mt))
  
  ## read in bam file with input seqlev specified by users
  which <- as(seqinfo(mt), "GRanges")
  param <- ScanBamParam(which=which)
  if(anchor=="cut site"){
    bamIn <- mapply(function(.b, .i) readGAlignments(.b, .i, param = param), 
                    bamfiles, index, SIMPLIFY = FALSE)
  }else{
    bamIn <- mapply(function(.b, .i) readGAlignmentPairs(.b, .i, param = param), 
                    bamfiles, index, SIMPLIFY = FALSE)
  }
  
  ##
  bamIn <- lapply(bamIn, as, Class = "GRanges")
  if(!is(bamIn, "GRangesList")) bamIn <- GRangesList(bamIn)
  bamIn <- unlist(bamIn)
  seqlevelsStyle(bamIn) <- seqlevelsStyle(genome)
  if(anchor=="cut site"){
    ## keep 5'end as cutting sites
    bamIn <- promoters(bamIn, upstream=0, downstream=1)
  }else{
    ## keep fragment center
    bamIn <- reCenterPeaks(bamIn, width=1)
  }
  
  ##
  libSize <- length(bamIn)
  coverageSize <- sum(as.numeric(width(reduce(bamIn, ignore.strand=TRUE))))
  libFactor <- libSize / coverageSize
  
  
  ## split into positive strand and negative strand
  bamIn <- split(bamIn, strand(bamIn))
 
  
  ## get coverage
  cvglist <- sapply(bamIn, coverage)
  cvglist <- cvglist[c("+", "-")]
  cvglist <- lapply(cvglist, function(.ele)
    .ele[names(.ele) %in% seqlev])
  
  ## coverage of mt, must be filtered, otherwise too much
  cvgSum <- cvglist[["+"]] + cvglist[["-"]]
  mt.s <- split(mt, seqnames(mt))
  seqlev <- intersect(names(cvgSum), names(mt.s))
  cvgSum <- cvgSum[seqlev]
  mt.s <- mt.s[seqlev]
  
  ## too much if use upstream and downstream, just use 3*wid maybe better.
  mt.s.ext <- promoters(mt.s, upstream=wid, downstream=wid+wid)
  stopifnot(all(lengths(mt.s.ext)==lengths(mt.s)))
  mt.v <- Views(cvgSum, mt.s.ext)
  mt.s <- mt.s[viewSums(mt.v)>0] 
  mt <- unlist(mt.s)
  mt.ids <- promoters(reCenterPeaks(mt, width=1),
                      upstream=upstream+floor(wid/2),
                      downstream=downstream+ceiling(wid/2)+1)
  mt.ids <- paste0(as.character(seqnames(mt.ids)), ":", start(mt.ids), "-", end(mt.ids))
  sigs <- featureAlignedSignal(cvglists=cvglist,
                              feature.gr=reCenterPeaks(mt, width=1),
                              upstream=upstream+floor(wid/2),
                              downstream=downstream+ceiling(wid/2),
                              n.tile=upstream+downstream+wid)
  mt <- mt[match(rownames(sigs[[1]]), mt.ids)]
  cor <- lapply(sigs, function(sig){
      sig.colMeans <- colMeans(sig)
      ## calculate correlation of footprinting and binding score
      windows <- slidingWindows(IRanges(1, ncol(sig)), width = wid, step = 1)[[1]]
      # remove the windows with overlaps of motif binding region
      windows <- windows[end(windows)<=upstream | start(windows)>=upstream+wid]
      sig.windowMeans <- viewMeans(Views(sig.colMeans, windows))
      windows.sel <- windows[which.max(sig.windowMeans)][1]
      highest.sig.windows <- 
          rowMeans(sig[, start(windows.sel):end(windows.sel)])
      predictedBindingSiteScore <- mt$score
      if(length(predictedBindingSiteScore) == length(highest.sig.windows)){
        suppressWarnings({
          cor <- cor.test(x = predictedBindingSiteScore, 
                          y = highest.sig.windows, 
                          method = "spearman")
        })
      }else{
        cor <- NA
      }
      cor
  })
  
  ###########################################################
  ## This is where you can insert the shuffled signals ######
  sigs <- lapply(sigs, function(.ele) .ele[mt$userdefined, ])
  ## Make the null model
  if (type == "nullmodel"){
  nums <- nrow(sigs[["+"]])
  cols <- ncol(sigs[["+"]])
  plusshuf <- matrix(data=NA, nrow=1000, ncol=cols)
  minusshuf <- matrix(data=NA, nrow=1000, ncol=cols)
  for (c in 1:nums){
    plusshuf[c,] <- as.double(sample(sigs[["+"]][c,], replace=FALSE))
    minusshuf[c,] <- as.double(sample(sigs[["-"]][c,], replace=FALSE))
  }
  sigs$"+" <- plusshuf
  sigs$"-" <- minusshuf
  }
  ###########################################################
  ###########################################################
  
  mt <- mt[mt$userdefined]
  mt$userdefined <- NULL
  
  ## segmentation the signals
  ## x2 because stranded.
  Profile <- lapply(sigs, function(.ele) colMeans(.ele, na.rm = TRUE)*2/libFactor)
  ## upstream + wid + downstream
  Profile.split <- lapply(Profile, function(.ele){
    list(upstream=.ele[seq.int(upstream)],
         binding=.ele[upstream+seq.int(wid)],
         downstream=.ele[upstream+wid+seq.int(downstream)])
  })
  
  ##
  optimalSegmentation <- function(.ele){
    .l <- length(.ele)
    short_abun <- cumsum(.ele)/seq.int(.l)
    long_abun <- cumsum(rev(.ele))/seq.int(.l)
    long_abun <- rev(long_abun)
    short_abun <- short_abun[-length(short_abun)]
    long_abun <- long_abun[-1]
    ##long_abun should always greater than short_abun
    long_abun <- long_abun - short_abun
    long_abun[long_abun<0] <- 0
    cov_diff <- numeric(length(short_abun))
    for(i in seq_along(.ele)){
      cov_diff_tmp <- .ele
      cov_diff_tmp <- cov_diff_tmp-short_abun[i]
      cov_diff_tmp[-seq.int(i)] <- cov_diff_tmp[-seq.int(i)] - long_abun[i]
      cov_diff[i] <- mean(cov_diff_tmp^2)
    }
    .ids <- which(cov_diff==min(cov_diff, na.rm = TRUE))
    data.frame(pos=.ids, short_abun=short_abun[.ids], long_abun=long_abun[.ids])
  }
  Profile.seg <- lapply(Profile.split, function(.ele){
    ups <- optimalSegmentation(.ele$upstream)
    downs <- optimalSegmentation(rev(.ele$downstream))
    ## find the nearest pair
    .min <- c(max(rbind(ups, downs)), 0, 0)
    for(i in seq.int(nrow(ups))){
      for(j in seq.int(nrow(downs))){
        tmp <- sum(abs(ups[i, -1] - downs[j, -1]))
        if(tmp < .min[1]){
          .min <- c(tmp, i, j)
        }
      }
    }
    c(colMeans(rbind(ups[.min[2], ], downs[.min[3], ])), binding=mean(.ele$binding, na.rm=TRUE))
  })
  
  ##
  Profile.seg <- colMeans(do.call(rbind, Profile.seg))
  Profile.seg[3] <- Profile.seg[2]+Profile.seg[3]
  names(Profile.seg)[2:3] <- c("distal_abun", "proximal_abun")
  
  pwm2pfm <- function(pfm, name="motif"){
  if(!all(round(colSums(pfm), digits=4)==1)){
    return(NULL)
  }
  new("pfm", mat=as.matrix(pfm), name=name)
}
  
  ## Input arguments for calling the plotFootprints function
  args <- list()
  args$Profile <- c(Profile[["+"]], Profile[["-"]])
  args$ylab <- ifelse(anchor=="cut site", "Cut-site probability", "reads density (arbitrary unit)")
  args$Mlen <- wid
  args$motif <- pwm2pfm(pfm)
  args$segmentation <- Profile.seg
  
  if (type == "nullmodel"){
  args$nullplus <- sigs$"+"
  args$nullminus <- sigs$"-"
  }
  
  return(args)
}

```

Function: generateFPHeatmaps
```{r}

generateFPHeatmaps <- function(fullpaths, filenames){
  
  ## Get the number of files in the list
  numfiles <- length(filenames) # Get the number of inputs
  
  ## Iterate over all filenames
  for (a in 4:numfiles){
    
    #### Cleanup memory at each iteration ####
    cat(fullpaths[a])
    gc()
    #### end ####
    
    #### Load the signal object into workspace ####
    insig <- load(fullpaths[a])
    signals <- get(insig)
    
    ## Get the total number of entries in the signals
    num_entries <- length(signals[["signal"]][["+"]][,1]) # number of entries to parse
    ## Get the gene name and motif number index
    curfile <- filenames[a]
    # Get the gene name
    re <- regexpr("(^[A-Z1-9]*)", curfile, perl=TRUE)
    gene <- regmatches(curfile, re)
    # Get the motif index
    re <- regexpr("motif([1-9])_", curfile, perl=TRUE)
    mindex <- regmatches(curfile, re)
    re <- regexpr("[1-9]", mindex, perl=TRUE)
    mindex <- as.integer(regmatches(mindex, re))
    ## get the PWM
    PWM <- getMotifPWM(gene)
    PWM <- PWM[[mindex]]
    ## Width of the motif
    motif_width <- length(PWM[1,])
    numbp <- motif_width + upstream + downstream
    #### end ####
    
    #### Make the calculations matrix and subset to top 1000 ####
    calc_matrix <- matrix(data = NA, num_entries, 4) # matrix to store signal calculations
    colnames(calc_matrix) <- c("index","total","motif","ratio")
  
    ## Perform the matrix calculations
    for (b in 1:num_entries){
      calc_matrix[b,"index"] <- b
      calc_matrix[b,"total"] <- (sum(signals[["signal"]][["+"]][b,]) + sum(signals[["signal"]][["-"]][b,]))
      calc_matrix[b,"motif"] <- (sum(signals[["signal"]][["+"]][b,100:100+motif_width]) + sum(signals[["signal"]][["-"]][b,100:100+motif_width]))
      calc_matrix[b,"ratio"] <- (calc_matrix[b,"motif"] / calc_matrix[b,"total"])
    } # End matrix calculations

    ## Find the top 1000 total signal rows
    # sort the matrix by total signal
    sorted <- calc_matrix[order(calc_matrix[,"total"], decreasing = TRUE),]
    # get index of top 1000
    ind <- sorted[1:1000,"index"]

    ## Get the Granges to make the new FP graph
    gr <- signals[["bindingSites"]][ind]
    #### end ####
    
    #### Construct the filepaths for saving the svg files ####
    ## For FP graph
    savepath_fp <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_fp <- gsub("_wg_", "_top_", savepath_fp)
    savepath_fp <- gsub(".RData", "_fp.svg", savepath_fp)
    ## For heatmap
    savepath_heatmap <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_heatmap <- gsub("_wg_", "_top_", savepath_heatmap)
    savepath_heatmap <- gsub(".RData", "_heatmap.svg", savepath_heatmap)
    ## For FP null
    savepath_fp_null <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_fp_null <- gsub("_wg_", "_top_null_", savepath_fp_null)
    savepath_fp_null <- gsub(".RData", "_fp.svg", savepath_fp_null)
    ## For heatmap null
    savepath_heatmap_null <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_heatmap_null <- gsub("_wg_", "_top_", savepath_heatmap_null)
    savepath_heatmap_null <- gsub(".RData", "_null_heatmap.svg", savepath_heatmap_null)
    #### end ####
    
    
    #### Make the new graphs ####
    #
    sigs <- list()
    #sigs$signal[["+"]] <- (signals[["signal"]][["+"]][ind,]+signals[["signal"]][["-"]][ind,])
    sigs$signal[["+"]] <- (signals[["signal"]][["+"]][ind,])
    sigs$signal[["-"]] <- (signals[["signal"]][["-"]][ind,])
    
    ## FP graph
    prof <- makeProfile(gr, PWM, "normal")
    
    pwm2pfm <- function(pfm, name="motif"){
    if(!all(round(colSums(pfm), digits=4)==1)){
      return(NULL)
    }
    new("pfm", mat=as.matrix(pfm), name=name)
    }
    PWMin <- pwm2pfm(PWM)
    #
    svg(file = savepath_fp) # set the filepath for saving the svg figure
    ATACseqQC:::plotFootprints(prof$Profile,
                               Mlen=motif_width, motif=PWMin)
    dev.off()
    
    ## Heatmap graph
    svg(file = savepath_heatmap) 
    featureAlignedHeatmap(sigs$signal, 
                      feature.gr=reCenterPeaks(gr,
                                               width=numbp), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=numbp)
    dev.off()
    
    ## FP NULL graph
    prof <- makeProfile(gr, PWM, "nullmodel")
    
    pwm2pfm <- function(pfm, name="motif"){
    if(!all(round(colSums(pfm), digits=4)==1)){
      return(NULL)
    }
    new("pfm", mat=as.matrix(pfm), name=name)
    }
    PWMin <- pwm2pfm(PWM)
    #
    svg(file = savepath_fp_null) # set the filepath for saving the svg figure
    ATACseqQC:::plotFootprints(prof$Profile,
                               Mlen=motif_width, motif=PWMin)
    dev.off()
    
    ## Heatmap NULL graph
    svg(file = savepath_heatmap_null)
    nullsig <- list()
    nullsig[["signal"]][["+"]] <- prof$nullplus
    nullsig[["signal"]][["-"]] <- prof$nullminus
    featureAlignedHeatmap(nullsig$signal, 
                      feature.gr=reCenterPeaks(gr,
                                               width=numbp), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=numbp)
    dev.off()
    
    
    #### end ####
    
  } # end for (a in 1:num){
} # end generateFPHeatmaps function

```


```{r}
generateFPHeatmaps(fullpaths,filenames)
```


---
title: "atacGenerateNullFP"
author: "Jordan S. Kesner"
date: "November 13, 2018"
output: html_document
---

This script will be used to generate indiviudal null models at predicted motif binding sites across the genome when scanning for TF footprinting from ATAC-seq data. To generate these null models, the current model will need to:
- Consider the total signal (number of insertions) at each specific ~200 bp locus
- Use the actul underlying reference sequence of that ~200 bp stretch from the hg38 reference genome
- Use published or experimentally derived models of Tn5 sequence specific insertion bias
- For each locus, build a probablistic model of insertion site distributions based on the underlying sequence and Tn5 insertion bias
- Generate the null model graph by weighted random residstribution of the total observed signal at that site
- Importantly, the null model must be generated separately for the plus and minus strand, it can then be combined and compared to the combined signal from the reference observed signal at that sequence

These null models can then be used for a site-by-site comparison of the null model against the observed data to accept or reject the null hypothesis

Install/load libraries
```{r}
# source("https://bioconductor.org/biocLite.R")
# biocLite("ATACseqQC", suppressUpdates = TRUE)
# biocLite("BSgenome.Hsapiens.UCSC.hg38", suppressUpdates = TRUE)
# biocLite("GenomicRanges", suppressUpdates = TRUE)
#
library(ATACseqQC)
library(BSgenome.Hsapiens.UCSC.hg38)
library(GenomicRanges)

#install.packages("partitions")
library(partitions)

```


Retrieve underlying sequences for all motif sites ** work in progress **
```{r}
genome <- Hsapiens
gr <- H508_WT_01_CDX2_motif1_wg_signals[["bindingSites"]]
# subset for a quick run
gr <- gr[1:1000]

## Expand the Granges windows to 200 bp on either side of motif
for (a in 1:length(gr)){
    gr[a]@ranges@start <- as.integer(gr[a]@ranges@start - 200)
    #gr[a]@ranges@width <- as.integer(gr[a]@ranges@width + 400)
    }

# getSeq(ref genome, granges), retrieves sequences associated with the Granges sites
seqs <- getSeq(genome, gr, as.character = TRUE)


```





```{r}

plus <- H508_WT_01_HNF4A_motif3_wg_signals[["signal"]][["+"]]
minus <-  H508_WT_01_HNF4A_motif3_wg_signals[["signal"]][["-"]]

# combine the plus and minus strand signals
items <- nrow(plus)
bp <- length(plus[1,])
combined <- matrix(data=NA,nrow=items,ncol=bp)
# combine the signals
for (d in 1:items){combined[d,] <- plus[d,] + minus[d,]}

# calculate the total signal at each site
totals <- c() # total signal
mtotals <- c() # total signal in the motif
for (e in 1:items){
  totals[e] <- sum(combined[e,])
  mtotals[e] <- sum(combined[e,100:116])}

# retrieve the specified quantiles from the total signals
qnt <- quantile(totals, probs = c(0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1))
# retrieve the indices of the sites in the top 10% of total signal
topten <- which(totals > qnt[10])
# subset the sites data
sitesub <- combined[topten,]
# reset the number of inputs
items <- nrow(sitesub)

# recalculate the total signal at each site
totals <- c() # total signal
mtotals <- c() # total signal in the motif
for (f in 1:items){
  totals[f] <- sum(sitesub[f,])
  mtotals[f] <- sum(sitesub[f,100:116])}

# get the unique values for total signal in the threshold passing sites
unq <- unique(totals)

## Generate a list of null distributions for every value of input signal in the passing list
null_sim <- list()
num <- length(unq)
null_mean <- c()
for (g in 1:num){
  n <- 1000
  t <- unq[g]
  s <- 216
  m <- 16
  null_sim[[g]] <- generateNullFP(n,t,s,m)
  null_mean[g] <- mean(null_sim[[g]])}

## Calculate the test statistics
# list to store the results of the t-tests
ttest <- list()
# vector to store the p-values
pvalue <- c()
# vector to store the t-value
tvalue <- c()

# perform the statistical tests
num_sites <- nrow(sitesub)
for (h in 1:num_sites){
  current <- c(sitesub[h,])
  signal <- c(sum(current))
  # retrieve the appropriate null model
  nullmodel <- null_sim[[which(unq==signal)]]
  # do the t-test
  ttest[[h]] <- t.test(current[100:116], mu=mean(nullmodel), alternative="less", conf.level = 0.95)
  pvalue[h] <- ttest[[h]][["p.value"]]
  tvalue[h] <- ttest[[h]][["statistic"]][["t"]]} 

# get the indices of the sites that are lower than p = 0.05
ind <- which(pvalue < 0.05)
ppass <- pvalue[ind]

# plot the p-values
# breaks specifies the number of bins
# col specifies the bin fill colors
# main specifies the title text
# freq if TRUE y axis is frequency of occurences, if FALSE y axis is probability density
hist(pvalue, breaks=20,col="blue",main="p-value distribution", freq=TRUE)
hist(tvalue, breaks=20, col="red",main="t-value distribution", freq=TRUE, xlim=c(-50,50))
hist(ppass)

# perform a Mann-Whitney U test
#wilcox.test(nn,mean(averages))




```






function generateNullFP
```{r}

generateNullFP <- function(n, t, s, m){
  
  # declare vector of size n to store average motif signal values
  averages <- c()

  # generate the null models and calculate motif averages
  for (a in 1:n){
    
    # declare the null vector
    null <- c(1:(s))
    
    # randomly distribute the total signal
    # size = the number of values to distribute
    # prob = probability of each site
    # length = length of the generated vector
    null <- c(as.vector(rmultinom(1, size=t, prob=rep(1, length(null)))))
    
    # calculate the average signal in the motif region
    b <- (s - 100 - m) # start of motif
    c <- (s - 100) # end of motif
    avg <- sum(null[b:c])
    avg <- (avg/m)

    # store the values
    averages[a] <- avg
    
    ### plotting
    # make the density plot
  # generate the density distribution
  # adjust can be modified to adjust the kernel estimation bandwidth
  #d <- density(averages, adjust=1, from=0)
  # make the plot
  # main can be specified to make a chart title
  # make the title string
  #title <- paste0("Motif signal means", "\n", "n = ", n, ", input signal = ", t, ", motif size = ", m)
  #plot(d, main=title)
  ## check for uniform distribution with QQ plot
  #qqplot(averages, runif(1000))
  #abline(0,1)

  } # end for (a in 1:n)
  return(averages)
} # end generateNullFP function

```



---
title: "atacFPHeatMaps"
author: "Jordan S. Kesner"
date: "November 10, 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

Install/load packages
```{r}
library(ATACseqQC)
library(BSgenome.Hsapiens.UCSC.hg38)
library(MotifDb)
library(ChIPpeakAnno)
library(Rsamtools)
library(GenomicAlignments)
library(crayon)
```

Input filepaths and parameters
```{r}
# specify the parent directory sigs
parentpath <- "/home/rstudio2/atac/ls1034/sigs/"
filenames <- list.files(parentpath)
fullpaths <- c(paste0(parentpath,filenames))
line <- "ls1034"

## params
motif_score <- "90%" # Minimum PWM matching score to consider a locus a hit, expressed as percentage
scope <- paste0("chr", c(1:22, "X", "Y")) # Where to look in the genome, default is paste0("chr", c(1:22, "X", "Y"))
genome <- Hsapiens
bampath <- "/home/rstudio2/atac/ls1034/bam/ls1034_all_dedup.bam"
baipath <- "/home/rstudio2/atac/ls1034/bam/ls1034_all_dedup.bam.bai"
upstream <- 100
downstream <- 100

```

getMotifPWM function
```{r}
getMotifPWM <- function(symbol){
  #### Reporting ####
  cat(black$bold(bgWhite("getMotifPWM current input argument:",
                         (red$bold(symbol)),
                         "\n"
                       )))
  #### end ####
  
  #### Query MotifDb ####
  # Define string to return only Hsapiens motifs
  organism_rows = grep('Hsapiens', values(MotifDb)$organism, ignore.case = TRUE)
  # Define string for given gene
  gene_symbol_rows = grep(symbol, values(MotifDb)$geneSymbol, ignore.case = TRUE)
  # Get indices for the intersection of gene and organism
  human_gene_rows = intersect(gene_symbol_rows, organism_rows)
  # Pull the PWMs
  # need to make it a list to use unique() function to remove duplicate entries
  gene_motifs <- as.list(MotifDb[human_gene_rows])
  # Get unique motifs
  unique_gene_motifs <- unique(gene_motifs)
  # Get number of motifs
  number_unique_gene_motifs <- length(unique_gene_motifs)
  #### end ####
  
  #### Reporting ####
  # total motifs found
  cat(black$bold(bgWhite("Number of motifs found in database:",
                         (red$bold(length(gene_motifs))),
                         "\n"
                       )))
  # unique motifs found
  cat(black$bold(bgWhite("Number of unique motifs:",
                       (red$bold(length(unique_gene_motifs))),
                       "\n",
                       "\n"
                       )))
  #### end ####
  
  #### Return PWM ####
  # Make a vector containing all the motifs
  unique_gene_motifs.vector <- c()
  for (a in 1:number_unique_gene_motifs) {
    unique_gene_motifs.vector[a] <- unique_gene_motifs[a]
  }
  
  # return the vector
  return(unique_gene_motifs.vector)
  #### end ####
  
  } # end getMotifPWM function
```

Generate the **Profile** to provide plotFootprints
```{r}

makeProfile <- function(sites, PWM, type){
  
  anchor <- c("cut site")
  pfm <- PWM  
  min.score <- motif_score
  bindingSites <- sites
  seqlev <- scope
  bamfiles <- bampath
  index <- baipath

      stopifnot(is(bindingSites, "GRanges"))
      stopifnot(all(!is.na(seqlengths(bindingSites))))
      stopifnot(length(bindingSites)>1)
      stopifnot(length(bindingSites$score)==length(bindingSites))
      mt <- bindingSites
      mt$userdefined <- TRUE
  
  wid <- ncol(pfm)
  seqlevels(mt) <- seqlev
  seqinfo(mt) <- Seqinfo(seqlev, seqlengths = seqlengths(mt))
  
  ## read in bam file with input seqlev specified by users
  which <- as(seqinfo(mt), "GRanges")
  param <- ScanBamParam(which=which)
  if(anchor=="cut site"){
    bamIn <- mapply(function(.b, .i) readGAlignments(.b, .i, param = param), 
                    bamfiles, index, SIMPLIFY = FALSE)
  }else{
    bamIn <- mapply(function(.b, .i) readGAlignmentPairs(.b, .i, param = param), 
                    bamfiles, index, SIMPLIFY = FALSE)
  }
  
  ##
  bamIn <- lapply(bamIn, as, Class = "GRanges")
  if(!is(bamIn, "GRangesList")) bamIn <- GRangesList(bamIn)
  bamIn <- unlist(bamIn)
  seqlevelsStyle(bamIn) <- seqlevelsStyle(genome)
  if(anchor=="cut site"){
    ## keep 5'end as cutting sites
    bamIn <- promoters(bamIn, upstream=0, downstream=1)
  }else{
    ## keep fragment center
    bamIn <- reCenterPeaks(bamIn, width=1)
  }
  
  ##
  libSize <- length(bamIn)
  coverageSize <- sum(as.numeric(width(reduce(bamIn, ignore.strand=TRUE))))
  libFactor <- libSize / coverageSize
  
  
  ## split into positive strand and negative strand
  bamIn <- split(bamIn, strand(bamIn))
 
  
  ## get coverage
  cvglist <- sapply(bamIn, coverage)
  cvglist <- cvglist[c("+", "-")]
  cvglist <- lapply(cvglist, function(.ele)
    .ele[names(.ele) %in% seqlev])
  
  ## coverage of mt, must be filtered, otherwise too much
  cvgSum <- cvglist[["+"]] + cvglist[["-"]]
  mt.s <- split(mt, seqnames(mt))
  seqlev <- intersect(names(cvgSum), names(mt.s))
  cvgSum <- cvgSum[seqlev]
  mt.s <- mt.s[seqlev]
  
  ## too much if use upstream and downstream, just use 3*wid maybe better.
  mt.s.ext <- promoters(mt.s, upstream=wid, downstream=wid+wid)
  stopifnot(all(lengths(mt.s.ext)==lengths(mt.s)))
  mt.v <- Views(cvgSum, mt.s.ext)
  mt.s <- mt.s[viewSums(mt.v)>0] 
  mt <- unlist(mt.s)
  mt.ids <- promoters(reCenterPeaks(mt, width=1),
                      upstream=upstream+floor(wid/2),
                      downstream=downstream+ceiling(wid/2)+1)
  mt.ids <- paste0(as.character(seqnames(mt.ids)), ":", start(mt.ids), "-", end(mt.ids))
  sigs <- featureAlignedSignal(cvglists=cvglist,
                              feature.gr=reCenterPeaks(mt, width=1),
                              upstream=upstream+floor(wid/2),
                              downstream=downstream+ceiling(wid/2),
                              n.tile=upstream+downstream+wid)
  mt <- mt[match(rownames(sigs[[1]]), mt.ids)]
  cor <- lapply(sigs, function(sig){
      sig.colMeans <- colMeans(sig)
      ## calculate correlation of footprinting and binding score
      windows <- slidingWindows(IRanges(1, ncol(sig)), width = wid, step = 1)[[1]]
      # remove the windows with overlaps of motif binding region
      windows <- windows[end(windows)<=upstream | start(windows)>=upstream+wid]
      sig.windowMeans <- viewMeans(Views(sig.colMeans, windows))
      windows.sel <- windows[which.max(sig.windowMeans)][1]
      highest.sig.windows <- 
          rowMeans(sig[, start(windows.sel):end(windows.sel)])
      predictedBindingSiteScore <- mt$score
      if(length(predictedBindingSiteScore) == length(highest.sig.windows)){
        suppressWarnings({
          cor <- cor.test(x = predictedBindingSiteScore, 
                          y = highest.sig.windows, 
                          method = "spearman")
        })
      }else{
        cor <- NA
      }
      cor
  })
  
  ###########################################################
  ## This is where you can insert the shuffled signals ######
  sigs <- lapply(sigs, function(.ele) .ele[mt$userdefined, ])
  ## Make the null model
  if (type == "nullmodel"){
  nums <- nrow(sigs[["+"]])
  cols <- ncol(sigs[["+"]])
  plusshuf <- matrix(data=NA, nrow=1000, ncol=cols)
  minusshuf <- matrix(data=NA, nrow=1000, ncol=cols)
  for (c in 1:nums){
    plusshuf[c,] <- as.double(sample(sigs[["+"]][c,], replace=FALSE))
    minusshuf[c,] <- as.double(sample(sigs[["-"]][c,], replace=FALSE))
  }
  sigs$"+" <- plusshuf
  sigs$"-" <- minusshuf
  }
  ###########################################################
  ###########################################################
  
  mt <- mt[mt$userdefined]
  mt$userdefined <- NULL
  
  ## segmentation the signals
  ## x2 because stranded.
  Profile <- lapply(sigs, function(.ele) colMeans(.ele, na.rm = TRUE)*2/libFactor)
  ## upstream + wid + downstream
  Profile.split <- lapply(Profile, function(.ele){
    list(upstream=.ele[seq.int(upstream)],
         binding=.ele[upstream+seq.int(wid)],
         downstream=.ele[upstream+wid+seq.int(downstream)])
  })
  
  ##
  optimalSegmentation <- function(.ele){
    .l <- length(.ele)
    short_abun <- cumsum(.ele)/seq.int(.l)
    long_abun <- cumsum(rev(.ele))/seq.int(.l)
    long_abun <- rev(long_abun)
    short_abun <- short_abun[-length(short_abun)]
    long_abun <- long_abun[-1]
    ##long_abun should always greater than short_abun
    long_abun <- long_abun - short_abun
    long_abun[long_abun<0] <- 0
    cov_diff <- numeric(length(short_abun))
    for(i in seq_along(.ele)){
      cov_diff_tmp <- .ele
      cov_diff_tmp <- cov_diff_tmp-short_abun[i]
      cov_diff_tmp[-seq.int(i)] <- cov_diff_tmp[-seq.int(i)] - long_abun[i]
      cov_diff[i] <- mean(cov_diff_tmp^2)
    }
    .ids <- which(cov_diff==min(cov_diff, na.rm = TRUE))
    data.frame(pos=.ids, short_abun=short_abun[.ids], long_abun=long_abun[.ids])
  }
  Profile.seg <- lapply(Profile.split, function(.ele){
    ups <- optimalSegmentation(.ele$upstream)
    downs <- optimalSegmentation(rev(.ele$downstream))
    ## find the nearest pair
    .min <- c(max(rbind(ups, downs)), 0, 0)
    for(i in seq.int(nrow(ups))){
      for(j in seq.int(nrow(downs))){
        tmp <- sum(abs(ups[i, -1] - downs[j, -1]))
        if(tmp < .min[1]){
          .min <- c(tmp, i, j)
        }
      }
    }
    c(colMeans(rbind(ups[.min[2], ], downs[.min[3], ])), binding=mean(.ele$binding, na.rm=TRUE))
  })
  
  ##
  Profile.seg <- colMeans(do.call(rbind, Profile.seg))
  Profile.seg[3] <- Profile.seg[2]+Profile.seg[3]
  names(Profile.seg)[2:3] <- c("distal_abun", "proximal_abun")
  
  pwm2pfm <- function(pfm, name="motif"){
  if(!all(round(colSums(pfm), digits=4)==1)){
    return(NULL)
  }
  new("pfm", mat=as.matrix(pfm), name=name)
}
  
  ## Input arguments for calling the plotFootprints function
  args <- list()
  args$Profile <- c(Profile[["+"]], Profile[["-"]])
  args$ylab <- ifelse(anchor=="cut site", "Cut-site probability", "reads density (arbitrary unit)")
  args$Mlen <- wid
  args$motif <- pwm2pfm(pfm)
  args$segmentation <- Profile.seg
  
  if (type == "nullmodel"){
  args$nullplus <- sigs$"+"
  args$nullminus <- sigs$"-"
  }
  
  return(args)
}

```

Function: generateFPHeatmaps
```{r}

generateFPHeatmaps <- function(fullpaths, filenames){
  
  ## Get the number of files in the list
  numfiles <- length(filenames) # Get the number of inputs
  
  ## Iterate over all filenames
  for (a in 4:numfiles){
    
    #### Cleanup memory at each iteration ####
    cat(fullpaths[a])
    gc()
    #### end ####
    
    #### Load the signal object into workspace ####
    insig <- load(fullpaths[a])
    signals <- get(insig)
    
    ## Get the total number of entries in the signals
    num_entries <- length(signals[["signal"]][["+"]][,1]) # number of entries to parse
    ## Get the gene name and motif number index
    curfile <- filenames[a]
    # Get the gene name
    re <- regexpr("(^[A-Z1-9]*)", curfile, perl=TRUE)
    gene <- regmatches(curfile, re)
    # Get the motif index
    re <- regexpr("motif([1-9])_", curfile, perl=TRUE)
    mindex <- regmatches(curfile, re)
    re <- regexpr("[1-9]", mindex, perl=TRUE)
    mindex <- as.integer(regmatches(mindex, re))
    ## get the PWM
    PWM <- getMotifPWM(gene)
    PWM <- PWM[[mindex]]
    ## Width of the motif
    motif_width <- length(PWM[1,])
    numbp <- motif_width + upstream + downstream
    #### end ####
    
    #### Make the calculations matrix and subset to top 1000 ####
    calc_matrix <- matrix(data = NA, num_entries, 4) # matrix to store signal calculations
    colnames(calc_matrix) <- c("index","total","motif","ratio")
  
    ## Perform the matrix calculations
    for (b in 1:num_entries){
      calc_matrix[b,"index"] <- b
      calc_matrix[b,"total"] <- (sum(signals[["signal"]][["+"]][b,]) + sum(signals[["signal"]][["-"]][b,]))
      calc_matrix[b,"motif"] <- (sum(signals[["signal"]][["+"]][b,100:100+motif_width]) + sum(signals[["signal"]][["-"]][b,100:100+motif_width]))
      calc_matrix[b,"ratio"] <- (calc_matrix[b,"motif"] / calc_matrix[b,"total"])
    } # End matrix calculations

    ## Find the top 1000 total signal rows
    # sort the matrix by total signal
    sorted <- calc_matrix[order(calc_matrix[,"total"], decreasing = TRUE),]
    # get index of top 1000
    ind <- sorted[1:1000,"index"]

    ## Get the Granges to make the new FP graph
    gr <- signals[["bindingSites"]][ind]
    #### end ####
    
    #### Construct the filepaths for saving the svg files ####
    ## For FP graph
    savepath_fp <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_fp <- gsub("_wg_", "_top_", savepath_fp)
    savepath_fp <- gsub(".RData", "_fp.svg", savepath_fp)
    ## For heatmap
    savepath_heatmap <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_heatmap <- gsub("_wg_", "_top_", savepath_heatmap)
    savepath_heatmap <- gsub(".RData", "_heatmap.svg", savepath_heatmap)
    ## For FP null
    savepath_fp_null <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_fp_null <- gsub("_wg_", "_top_null_", savepath_fp_null)
    savepath_fp_null <- gsub(".RData", "_fp.svg", savepath_fp_null)
    ## For heatmap null
    savepath_heatmap_null <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_heatmap_null <- gsub("_wg_", "_top_", savepath_heatmap_null)
    savepath_heatmap_null <- gsub(".RData", "_null_heatmap.svg", savepath_heatmap_null)
    #### end ####
    
    
    #### Make the new graphs ####
    #
    sigs <- list()
    #sigs$signal[["+"]] <- (signals[["signal"]][["+"]][ind,]+signals[["signal"]][["-"]][ind,])
    sigs$signal[["+"]] <- (signals[["signal"]][["+"]][ind,])
    sigs$signal[["-"]] <- (signals[["signal"]][["-"]][ind,])
    
    ## FP graph
    prof <- makeProfile(gr, PWM, "normal")
    
    pwm2pfm <- function(pfm, name="motif"){
    if(!all(round(colSums(pfm), digits=4)==1)){
      return(NULL)
    }
    new("pfm", mat=as.matrix(pfm), name=name)
    }
    PWMin <- pwm2pfm(PWM)
    #
    svg(file = savepath_fp) # set the filepath for saving the svg figure
    ATACseqQC:::plotFootprints(prof$Profile,
                               Mlen=motif_width, motif=PWMin)
    dev.off()
    
    ## Heatmap graph
    svg(file = savepath_heatmap) 
    featureAlignedHeatmap(sigs$signal, 
                      feature.gr=reCenterPeaks(gr,
                                               width=numbp), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=numbp)
    dev.off()
    
    ## FP NULL graph
    prof <- makeProfile(gr, PWM, "nullmodel")
    
    pwm2pfm <- function(pfm, name="motif"){
    if(!all(round(colSums(pfm), digits=4)==1)){
      return(NULL)
    }
    new("pfm", mat=as.matrix(pfm), name=name)
    }
    PWMin <- pwm2pfm(PWM)
    #
    svg(file = savepath_fp_null) # set the filepath for saving the svg figure
    ATACseqQC:::plotFootprints(prof$Profile,
                               Mlen=motif_width, motif=PWMin)
    dev.off()
    
    ## Heatmap NULL graph
    svg(file = savepath_heatmap_null)
    nullsig <- list()
    nullsig[["signal"]][["+"]] <- prof$nullplus
    nullsig[["signal"]][["-"]] <- prof$nullminus
    featureAlignedHeatmap(nullsig$signal, 
                      feature.gr=reCenterPeaks(gr,
                                               width=numbp), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=numbp)
    dev.off()
    
    
    #### end ####
    
  } # end for (a in 1:num){
} # end generateFPHeatmaps function

```


```{r}
generateFPHeatmaps(fullpaths,filenames)
```




---
title: "subsetARACNe"
author: "Jordan S. Kesner"
date: "November 5, 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

This script is used to modify a specific ARACNe interactome/regulon for use with VIPER analysis
Gene IDs are in ENTREZ format

Install and load packages
```{r}
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("aracne.networks", version = "3.8")
#BiocManager::install("org.Hs.eg.db")
#BiocManager::install("annotate")
#BiocManager::install("viper")
#install.packages("rlist")
library(aracne.networks)
library(org.Hs.eg.db)
library(annotate)
library(rlist)
library(viper)
```

Write COAD interactome to text file - this will take a long time  (~30-60 mins)
```{r}
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/") # Write the full interactome to a text file
```

The list of good vs. poor prognosis MRs with motifs:
TCF7 (6932)
MNX1 (3110)
POU5F1B (5462)
ESRRA (2101)
CDX2 (1045)
HNF4A (3172)
GMEB2 (26205)
HOXA3 (3200)
OVOL1 (5017)
ASCL2 (430)
ZSWIM1 (90204)
CBFA2T2 (9139)

FIRE
ADNP (23394)
ZNF696 (79943)
ZMYND8 (23613)
TAF4 (6874)

Write the MR regulons to file
```{r}
data(reguloncoad)
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/TCF7.txt", regulator="6932")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/MNX1.txt", regulator="3110")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/POU5F1B.txt", regulator="5462")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/ESRRA.txt", regulator="2101")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/CDX2.txt", regulator="1045")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/HNF4A.txt", regulator="3172")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/GMEB2.txt", regulator="26205")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/HOXA3.txt", regulator="3200")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/OVOL1.txt", regulator="5017")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/ASCL2.txt", regulator="430")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/ZSWIM1.txt", regulator="90204")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/CBFA2T2.txt", regulator="9139")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/ADNP.txt", regulator="23394")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/ZNF696.txt", regulator="79943")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/ZMYND8.txt", regulator="23613")
write.regulon(reguloncoad, file = "C:/Users/Jordan/Desktop/COAD_regulons/TAF4.txt", regulator="6874")
```

Read in the saved regulons
```{r}
## Note, must delete the first line in the text files first

# TCF7
coad_tcf7 <- matrix(data=NA, nrow=71, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/TCF7.txt"
con <- file(description=file,open="r")
for(i in 1:70){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_tcf7[i,1] <- tmp[1]
  coad_tcf7[i,2] <- tmp[2]
  coad_tcf7[i,3] <- tmp[3]
  coad_tcf7[i,4] <- tmp[4]}


# MNX1
coad_mnx1 <- matrix(data=NA, nrow=107, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/MNX1.txt"
con <- file(description=file,open="r")
for(i in 1:107){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_mnx1[i,1] <- tmp[1]
  coad_mnx1[i,2] <- tmp[2]
  coad_mnx1[i,3] <- tmp[3]
  coad_mnx1[i,4] <- tmp[4]}

# POU5F1B
coad_pou5f1b <- matrix(data=NA, nrow=227, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/POU5F1B.txt"
con <- file(description=file,open="r")
for(i in 1:227){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_pou5f1b[i,1] <- tmp[1]
  coad_pou5f1b[i,2] <- tmp[2]
  coad_pou5f1b[i,3] <- tmp[3]
  coad_pou5f1b[i,4] <- tmp[4]}

# ESRRA
coad_esrra <- matrix(data=NA, nrow=151, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/ESRRA.txt"
con <- file(description=file,open="r")
for(i in 1:151){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_esrra[i,1] <- tmp[1]
  coad_esrra[i,2] <- tmp[2]
  coad_esrra[i,3] <- tmp[3]
  coad_esrra[i,4] <- tmp[4]}

# CDX2
coad_cdx2 <- matrix(data=NA, nrow=97, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/CDX2.txt"
con <- file(description=file,open="r")
for(i in 1:97){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_cdx2[i,1] <- tmp[1]
  coad_cdx2[i,2] <- tmp[2]
  coad_cdx2[i,3] <- tmp[3]
  coad_cdx2[i,4] <- tmp[4]}

# HNF4A
coad_hnf4a <- matrix(data=NA, nrow=91, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/MNX1.txt"
con <- file(description=file,open="r")
for(i in 1:91){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_hnf4a[i,1] <- tmp[1]
  coad_hnf4a[i,2] <- tmp[2]
  coad_hnf4a[i,3] <- tmp[3]
  coad_hnf4a[i,4] <- tmp[4]}

# GMEB2
coad_gmeb2 <- matrix(data=NA, nrow=289, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/GMEB2.txt"
con <- file(description=file,open="r")
for(i in 1:289){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_gmeb2[i,1] <- tmp[1]
  coad_gmeb2[i,2] <- tmp[2]
  coad_gmeb2[i,3] <- tmp[3]
  coad_gmeb2[i,4] <- tmp[4]}

# HOXA3
coad_hoxa3 <- matrix(data=NA, nrow=93, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/MNX1.txt"
con <- file(description=file,open="r")
for(i in 1:93){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_hoxa3[i,1] <- tmp[1]
  coad_hoxa3[i,2] <- tmp[2]
  coad_hoxa3[i,3] <- tmp[3]
  coad_hoxa3[i,4] <- tmp[4]}

# OVOL1
coad_ovol1 <- matrix(data=NA, nrow=149, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/OVOL1.txt"
con <- file(description=file,open="r")
for(i in 1:149){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_ovol1[i,1] <- tmp[1]
  coad_ovol1[i,2] <- tmp[2]
  coad_ovol1[i,3] <- tmp[3]
  coad_ovol1[i,4] <- tmp[4]}

# ASCL2
coad_ascl2 <- matrix(data=NA, nrow=127, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/ASCL2.txt"
con <- file(description=file,open="r")
for(i in 1:127){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_ascl2[i,1] <- tmp[1]
  coad_ascl2[i,2] <- tmp[2]
  coad_ascl2[i,3] <- tmp[3]
  coad_ascl2[i,4] <- tmp[4]}

# ZSWIM1
coad_zswim1 <- matrix(data=NA, nrow=108, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/ZSWIM1.txt"
con <- file(description=file,open="r")
for(i in 1:108){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_zswim1[i,1] <- tmp[1]
  coad_zswim1[i,2] <- tmp[2]
  coad_zswim1[i,3] <- tmp[3]
  coad_zswim1[i,4] <- tmp[4]}

# CBFA2T2
coad_cbfa2t2 <- matrix(data=NA, nrow=152, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/CBFA2T2.txt"
con <- file(description=file,open="r")
for(i in 1:152){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_cbfa2t2[i,1] <- tmp[1]
  coad_cbfa2t2[i,2] <- tmp[2]
  coad_cbfa2t2[i,3] <- tmp[3]
  coad_cbfa2t2[i,4] <- tmp[4]}

# ADNP
coad_adnp <- matrix(data=NA, nrow=146, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/ADNP.txt"
con <- file(description=file,open="r")
for(i in 1:146){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_adnp[i,1] <- tmp[1]
  coad_adnp[i,2] <- tmp[2]
  coad_adnp[i,3] <- tmp[3]
  coad_adnp[i,4] <- tmp[4]}

# ZNF696
coad_znf696 <- matrix(data=NA, nrow=74, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/ZNF696.txt"
con <- file(description=file,open="r")
for(i in 1:74){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_znf696[i,1] <- tmp[1]
  coad_znf696[i,2] <- tmp[2]
  coad_znf696[i,3] <- tmp[3]
  coad_znf696[i,4] <- tmp[4]}

# ZMYND8
coad_zmynd8 <- matrix(data=NA, nrow=127, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/ZMYND8.txt"
con <- file(description=file,open="r")
for(i in 1:127){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_zmynd8[i,1] <- tmp[1]
  coad_zmynd8[i,2] <- tmp[2]
  coad_zmynd8[i,3] <- tmp[3]
  coad_zmynd8[i,4] <- tmp[4]}

# TAF4
coad_taf4 <- matrix(data=NA, nrow=122, ncol=4)
file <- "C:/Users/Jordan/Desktop/COAD_regulons/TAF4.txt"
con <- file(description=file,open="r")
for(i in 1:122){
  tmp <- scan(file=con, nlines = 1, quiet=TRUE)
  coad_taf4[i,1] <- tmp[1]
  coad_taf4[i,2] <- tmp[2]
  coad_taf4[i,3] <- tmp[3]
  coad_taf4[i,4] <- tmp[4]}

```

Make a list of the regulons
```{r}
coad_regulons <- list()
coad_regulons[[1]] <- coad_adnp
coad_regulons[[2]] <- coad_ascl2
coad_regulons[[3]] <- coad_cbfa2t2
coad_regulons[[4]] <- coad_cdx2
coad_regulons[[5]] <- coad_esrra
coad_regulons[[6]] <- coad_gmeb2
coad_regulons[[7]] <- coad_hnf4a
coad_regulons[[8]] <- coad_hoxa3
coad_regulons[[9]] <- coad_mnx1
coad_regulons[[10]] <- coad_ovol1
coad_regulons[[11]] <- coad_pou5f1b
coad_regulons[[12]] <- coad_taf4
coad_regulons[[13]] <- coad_tcf7
coad_regulons[[14]] <- coad_zmynd8
coad_regulons[[15]] <- coad_znf696
coad_regulons[[16]] <- coad_zswim1

# remove the single versions, if wanted
rm(coad_adnp, coad_ascl2, coad_cbfa2t2, coad_cdx2, coad_esrra, coad_gmeb2, coad_hnf4a, coad_hoxa3, coad_mnx1, coad_ovol1, coad_pou5f1b, coad_taf4, coad_tcf7, coad_zmynd8, coad_znf696, coad_zswim1)


```


Convert between ENTREZ and GENE SYMBOL ** working on it **
```{r}

```









Code to tinker with interactome
```{r}
gene_id <- "10002"
setwd("C:/Users/Jordan/Desktop/")
#interactome_tinker <- read.table(file = "COAD_interactome.txt", sep = "\t") # read in the interactome from text file
interactome_tinker <- read.table(file = "network_coad_tfCotf_3col_sorted.txt", sep = "\t")
regulon_req <- interactome_tinker[which(interactome_tinker[,1] == gene_id),] # getting req regulon to tinker
interactome_tinker <- interactome_tinker[-(which(interactome_tinker[,1] == gene_id)),] # removing the original regulon from interactome
#colnames(regulon_motifMI) <- colnames(regulon_req)
write.table(interactome_tinker, file = "COAD_interactome_tinkered.txt", sep = "\t", append = FALSE, row.names = FALSE, col.names = FALSE) # write the modified interactome to file

mod_interactome <- aracne2regulon("COAD_interactome_tinkered.txt", dset, format = "3col", verbose = TRUE) # regenerate the new interactome

print(regul)
#coadViper <- viper(dset, regul, method = "scale") #the viper algorithm
#dim(coadViper)


### below is directly from Ajay
#2018 Nov 6
#code to tinker with interactome
library(viper)
setwd("C:/Users/Jordan/Desktop/")
# save(dset,regulon_motifMI, file = "dset_motifMIregulon.RData")
load(file = "dset_motifMIregulon.RData")#get the dset and regulon_motifMI
geneId <- "4089" #smad4
interactome_tinker <- read.table(file = "network_coad_tfCotf_3col_sorted.txt", sep = "\t")
regulon_req <- interactome_tinker[which(interactome_tinker[,1]==geneId),]#getting req regulon to tinker
interactome_tinker <- interactome_tinker[-(which(interactome_tinker[,1]==geneId)),]# removing the req regulon from interactome
colnames(regulon_motifMI) <- colnames(regulon_req)
regulon_req <- rbind(regulon_req,regulon_motifMI)
regulon_req <- regulon_req[order(regulon_req[,3], decreasing = TRUE),]
write.table(interactome_tinker, file = "network_coad_tfCotf_3col_tinkered.txt", sep = "\t", append = FALSE, row.names = FALSE, col.names = FALSE)
write.table(regulon_req, file = "network_coad_tfCotf_3col_tinkered.txt", sep = "\t", append = TRUE, row.names = FALSE, col.names = FALSE)
regul <- aracne2regulon("network_coad_tfCotf_3col_tinkered.txt", dset, format = "3col", verbose = TRUE)#regulon
#
#
print(regul)

coadViper <- viper(dset, regul, method = "scale") # the viper algorithm. takes only a few minutes to run
dim(coadViper)

plot(coadViper, mrs = 10, color = c("cornflowerblue", "salmon"),
pval = NULL, bins = 500, cex = 0, density = 0, smooth = 0,
sep = 0.2, hybrid = TRUE, include = c("expression", "activity"),
gama = 2)



```

removeTargets
```{r}
## A function to remove targets from all regulator regulons in network
## This is used when a specific set of genes is determined to be in a region of constituitive heterochromatin
## Not sure if it will work, but can try to set tfmode to 0 instead of removing edge
removeTargets <- function(interactome, genes){

}

a <- c(as.character("158056"), as.character("57096"))
list.remove(reguloncoad[["10002"]], a)
lis <- vector("list", 3)
lis[[3]] <- NULL

list.remove(reguloncoad[["10009"]][["tfmode"]][["10735"]], c("10735"))


names <- as.character(names(reguloncoad)) # get the entrez ids in the list
symbols <- c()
for (a in 1:length(names)){symbols[a] <- getSYMBOL(names[a], "org.Hs.eg")} # convert the entrez ids to gene symbols


## Remove a set of target genes from all regulator regulons
## This should be used when a gene is determined to be located in constituitive heterochromatin
remove_list <- c("TCF7")
remove_num <- length(remove_list)

reguloncoad[["10002"]]

# save(dset,regulon_motifMI, file = "dset_motifMIregulon.RData")
#load(file = "dset_motifMIregulon.RData")#get the dset and regulon_motifMI
#geneId <- "4089" #smad4

data(package="aracne.networks")$results[, "Item"] # show available packages
data(regulonblca) 
write.regulon(regulonblca, n = 10) # write regulon to file, with 10 interactions
data(regulonblca)
write.regulon(regulonblca, regulator="399") # analyze a specific regulon
getSYMBOL("6932", "org.Hs.eg") # this function converts an ENTREZ ID into a gene symbol

data(reguloncoad) # load the interactome from the package
reguloncoad # data is loaded as a promise object, must interact with it to conver to df
regulators <- names(reguloncoad) # returns list of all regulators in interactome
targets <- c() # a vector to hold the targets
for (a in 1:length(regulators)){targets <- c(targets, names(reguloncoad[[a]][["tfmode"]]))} # populate targets vector
unique <- c(regulators, targets) # merge targets and regulators list
unique <- unique(unique) # get unique entries
gene_id <- matrix(data = NA, ncol = 2, nrow = length(unique)) # a matrix that will hold ENTREZ and SYMBOL for all unique genes
for (b in 1:length(unique)){
  ent <- as.character(unique[[b]]); sym <- as.character(getSYMBOL(ent, "org.Hs.eg"))
  gene_id[b,1] <- ent; gene_id[b,2] <- sym}
rm(regulators, targets, a, b, ent, sym, unique) # cleanup

colnames(regulon_motifMI) <- colnames(regulon_req)
regulon_req <- rbind(regulon_req,regulon_motifMI)
regulon_req <- regulon_req[order(regulon_req[,3], decreasing = TRUE),]
```



