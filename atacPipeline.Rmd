---
title: "atacPipeline"
author: "Jordan S. Kesner"
date: "8/20/2018"
output: html_document
editor_options: 
chunk_output_type: console
---

Install and load libraries
```{r}
## R packages
#install.packages("RCurl")
#install.packages("ggplot2")
#install.packages("stringr")
#install.packages("devtools")
#install.packages("cluster")
#install.packages("seriation")
#install.packages("igraph")
#install.packages("dplyr")
#install.packages("mclust")
#biocLite("affxparser", suppressUpdates = TRUE)
#install.packages("partitions")
#install.packages("gmp")
#devtools::install_github("r-lib/crayon")

## Bioconductor packages
#source("https://bioconductor.org/biocLite.R")
#biocLite("ATACseqQC", suppressUpdates = TRUE)
#biocLite("ChIPpeakAnno", suppressUpdates = TRUE)
#biocLite("MotifDb", suppressUpdates=TRUE)
#biocLite("BSgenome.Hsapiens.UCSC.hg38", suppressUpdates = TRUE)
#biocLite("TxDb.Hsapiens.UCSC.hg38.knownGene", suppressUpdates = TRUE)
#biocLite("phastCons100way.UCSC.hg38", suppressUpdates = TRUE)
#biocLite("MotIV", suppressUpdates = TRUE)
#biocLite("seqLogo", suppressUpdates = TRUE)
#biocLite("PWMEnrich", suppressUpdates = TRUE)
#biocLite("GenomicRanges", suppressUpdates = TRUE)
#biocLite("stringi", suppressUpdates = TRUE)
#biocLite("ensembldb", suppressUpdates = TRUE)
#biocLite("EnsDb.Hsapiens.v86", suppressUpdates = TRUE)
#biocLite("S4Vectors", suppressUpdates = TRUE)
#biocLite("Rsubread", suppressUpdates = TRUE)
#biocLite("Repitools", suppressUpdates = TRUE)
biocLite("chromoMap", suppressUpdates = TRUE)

## Load libraries
library(ATACseqQC)
library(ggplot2)
library(reshape2)
library(seriation)
library(igraph)
library(dplyr)
library(cluster)
library(mclust)
library(BSgenome.Hsapiens.UCSC.hg38)
library(MotifDb)
library(GenomicRanges)
library(crayon)
library(MotifDb)
library(MotIV)
library(seqLogo)
library(stringr)
library(PWMEnrich)
library(partitions)
library(Repitools)
library(ensembldb)
library(EnsDb.Hsapiens.v86)
library(S4Vectors)
library(ChIPpeakAnno)
library(Rsamtools)
library(chromoMap)
#library(Rsubread) # does not work on windows
```

Change dynamic variables here
```{r}
## initial gc()
gc()

## Troubleshooting mode
## When true, pipeline will output a report to the console at processing steps
ts <- TRUE

## PWM mode
## Default option is to automatically pull motifs from motifDb : "DEFAULT"
## Custom option allows you to supply a list of PWMs to the pipeline : "CUSTOM"
## If choosing the custom mode, you must supply a list of gene names in the proper order to correspond to the PWMs in the other list
## The format for the gene names is : <SYMBOL>_<motifN>, where N is an integer
#
PWM_mode <- "CUSTOM" # DEAFULT or CUSTOM
#
custom_genes <- c("ADNP_motif1_fire_PWM", "TAF4_motif1_fire_PWM", "TAF4_motif2_fire_PWM", "ZMYND8_motif1_fire_PWM", "ZNF696_motif1_fire_PWM", "ZNF696_motif2_fire_PWM", "ZNF696_motif3_fire_PWM") # NULL if DEFAULT mode is selected
#
custom_PWMs <- COAD_FIRE_PWM # NULL if default mode is selected


## Run name. Very important to set and make unique if doing a new run
## Suggested naming convention is <Cell line>_<WT or mutation info>_<integer specifying experimental replicate, e.g. 01>
run_name <- "H508_WT_01"

## make the test ranges object
testRanges <- GRanges(
                    seqnames = c(paste0("chr", c(1:22, "X", "Y"))),
                    ranges = IRanges(start = rep(10000, times = 24), end = rep(10500, times = 24)),
                    strand = c(rep("+", times = 24)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = 24)))

## Required parameters
path_to_parent_dir <- "/home/rstudio2/atac/h508/" # Full path to parent directory, including slash at end
bam_base_filename <- "h508_all_dedup.bam" # Base filename of bam input file, must be located in /bam
binding_sites <- NULL # Optional, specify binding sites to use in signal generation. Deafult = NULL
motif_score <- "90%" # Minimum PWM matching score to consider a locus a hit, expressed as percentage
upstream <- 100 # scan signal x bp upstream of motif match
downstream <- 100 # scan signal x bp downstream of motif match
scope <- paste0("chr", c(1:22, "X", "Y")) # Where to look in the genome, default is paste0("chr", c(1:22, "X", "Y"))

## Optional parameters
parse_option <- FALSE
parse_type <- "Q" # Default is Q - quantile
parse_num <- "FULL" # How many total sites to parse. Default is FULL
bindingsites_option <- FALSE

## List of gene symbols for genes to be analyzed
  genes_to_be_analyzed <- c(
                           "TCF7"
                           )


#### DO NOT MODIFY ####
# Call the setVars function to import and process the dynamic variables
setVars(path_to_parent_dir, bam_base_filename, motif_score, upstream, downstream, scope, genes_to_be_analyzed, parse_option, parse_type, bindingsites_option, run_name, parse_num)
# Cleanup the workspace
rm(path_to_parent_dir, bam_base_filename, motif_score, upstream, downstream, scope, binding_sites, genes_to_be_analyzed, parse_option, bindingsites_option, parse_type, run_name, parse_num)
#### end ####
```

** Completed Functions **
```{r}

setVars <- function(parent, bam, score, upstream, downstream, scope, genes, parseoption, parse_type, bindingsites_option, run_name, parse_num, PWM_mode, custom_genes, custom_PWMs){

#### Set directory paths ####
# declare keyed list for storing directories
dir_list <<- list()
# Parent path
dir_list$parent <<- path_to_parent_dir
# sites path
dir_list$sites <<- paste0(path_to_parent_dir, "sites/")
# bam path
dir_list$bam <<- paste0(path_to_parent_dir, "bam/")
# graphs path
dir_list$graphs <<- paste0(path_to_parent_dir, "graphs/")
# pwm path
dir_list$pwm <<- paste0(path_to_parent_dir, "pwm/")
# sigs path
dir_list$sigs <<- paste0(path_to_parent_dir, "sigs/")
#### end ####

#### Set reference parameters ####
# declare keyed list for reference parameters
reference_parameters <<- list()
# bam base filename
reference_parameters$bam_base <<- bam
# bam filepath
reference_parameters$bam_filepath <<- as.character(paste0(dir_list$bam, reference_parameters$bam_base))
# bai index filepath
reference_parameters$bai_filepath <<- paste0(reference_parameters$bam_filepath, ".bai")
# reference genome to use
reference_parameters$genome <<- Hsapiens
# scope of analysis
reference_parameters$scope <<- scope
# minimum score for motif matching
reference_parameters$motif_score <<- score
# upstream from motif
reference_parameters$upstream <<- upstream
# downstream from motif
reference_parameters$downstream <<- downstream
#
# set input binding sites, if specified
#if(!is.null(sites)) {
#  reference_parameters$sites <<- sites
#}
#### end ####

#### Set genes and info LHS list DEFAULT OPTION ####
## Declare list for storing gene information
gene_info <<- list()
## transfer gene symbols and number of genes
gene_info$names <<- genes
gene_info$number <<- length(genes)

## iterate over each gene symbol, gather data and store in nested list
for (a in 1:gene_info[["number"]]) 
  {
  
  ## use getMotifPWM function to scan MotifDb for gene motifs
  info <- getMotifPWM(gene_info$names[a])
  
  # case 1 : at least one motif found in motifdb (not null)
  if (!is.null(info[[1]]))
    {
    
    ## copy data into nested list
    # copy the gene name
    string <- paste0("'", gene_info[["names"]][[a]], "'")
    command <- paste0("gene_info$genes$", gene_info[["names"]][[a]],"$name", " <<- ", string)
    eval(parse(text = command))
    # set found in MotifDb to true
    string <- paste0("'", "TRUE", "'")
    command <- paste0("gene_info$genes$", gene_info[["names"]][[a]],"$haspwm", " <<- ", string)
    eval(parse(text = command))
    # set number of unique motifs found in MotifDb
    string <- paste0("'", length(info), "'")
    command <- paste0("gene_info$genes$", gene_info[["names"]][[a]],"$motifs", " <<- ", string)
    eval(parse(text = command))
    
    ## copy the unique motifs to gene list
    # generate names for keys in main gene_info list
    motifs <- c()
    for (b in 1:length(info))
      {
      motifs[b] <- paste0("motif", b)
      }
    
    # copy the motif matrices to the gene_info list
    for (c in 1:length(info))
      {
      # copy the name of the current motif (motif1, motif2, etc)
      string <- motifs[c]
      # name of variable that holds the current motif matrix
      string2 <- "info[[c]]"
      # construct command
      command <- paste0("gene_info$genes$", gene_info[["names"]][[a]],"$matrix$", string, " <<- ", string2)
      # run the command as code
      eval(parse(text = command, keep.source = getOption("keep.source")))
      }
    }
  # case 2 : no motifs found in motifdb for current gene (null)
  if (is.null(info[[1]]))
    {
    ## copy data into nested list
    # copy the gene name
    string <- paste0("'", gene_info[["names"]][[a]], "'")
    command <- paste0("gene_info$genes$", gene_info[["names"]][[a]],"$name", " <<- ", string)
    eval(parse(text = command))
    # set found in MotifDb to true
    string <- paste0("'", "FALSE", "'")
    command <- paste0("gene_info$genes$", gene_info[["names"]][[a]],"$haspwm", " <<- ", string)
    eval(parse(text = command))
    # set number of unique motifs found in MotifDb
    string <- paste0("'", 0, "'")
    command <- paste0("gene_info$genes$", gene_info[["names"]][[a]],"$motifs", " <<- ", string)
    eval(parse(text = command))
    }
  }
#### end ####

#### Set optional parameters ####
# declare keyed list for storing optional params
options_list <<- list()
options_list$parse <<- parse_option
options_list$parse_type <<- parse_type
options_list$parse_num <<- parse_num
options_list$binding_sites <<- bindingsites_option
#### end ####

#### Make records ####
## Constructs a list object that will store and record all information about this run, including filepaths
## This record object will be saved in the parent folder for record keeping
# Initiate the list
records <<- list()
# Run name
records$run_name <<- run_name
# Records object filepath for saving
records$records_path <<- paste0(dir_list$parent, run_name, "_records.Rdata")
# Directories
records$directories <<- dir_list
# Gene info
records$genes <<- gene_info
# Parameters
records$parameters <<- reference_parameters
## Construct the names and filepaths for each gene and unique motif
for (gene in gene_info[["genes"]]){ # Iterare over every input gene
    if (gene[["haspwm"]] == TRUE){ # Check that the current gene has at least one PWM from motifDb
      for (motif in names(gene[["matrix"]])){ # Iterate over all unique PWMs for current gene
        ## Create an entry in the records list for the current unique motif of the current gene
        ## Use the eval/parse construct to simplify referencing the variable names
        
        #### Generate object names and filepaths
        # R object name for signals. wg = whole genome
        signal_name <- paste0(run_name, "_", gene[["name"]], "_", motif, "_wg_signals")
        command <- paste0("records$", gene[["name"]], "_", motif, "$signal_name <<- signal_name")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        # Save filepath for signals object
        signal_path <- paste0(dir_list$sigs, gene[["name"]], "_", motif, "_wg_signals.RData")
        command <- paste0("records$", gene[["name"]], "_", motif, "$signal_path <<- signal_path")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        # R object name for sites. wg = whole genome
        sites_name <- paste0(gene[["name"]], "_", motif, "_wg_sites")
        command <- paste0("records$", gene[["name"]], "_", motif, "$sites_name <<- sites_name")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        # Save filepath for sites object
        sites_path <- paste0(dir_list$sites , gene[["name"]], "_", motif, "_wg_sites.RData")
        command <- paste0("records$", gene[["name"]], "_", motif, "$sites_path <<- sites_path")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        # Save filepath for svg footprint graph. wg = whole genome
        fp_path <- paste0(dir_list$graphs , gene[["name"]], "_", motif, "_wg.svg")
        command <- paste0("records$", gene[["name"]], "_", motif, "$graph_wg_path <<- fp_path")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        # R object names for parsed signals
        q1_signal_name <- paste0(run_name, "_", gene[["name"]], "_", motif, "_wg_Q1_signals")
        q2_signal_name <- paste0(run_name, "_", gene[["name"]], "_", motif, "_wg_Q2_signals")
        q3_signal_name <- paste0(run_name, "_", gene[["name"]], "_", motif, "_wg_Q3_signals")
        q4_signal_name <- paste0(run_name, "_", gene[["name"]], "_", motif, "_wg_Q4_signals")
        command <- paste0("records$", gene[["name"]], "_", motif, "$q1_signal_name <<- q1_signal_name")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("records$", gene[["name"]], "_", motif, "$q2_signal_name <<- q2_signal_name")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("records$", gene[["name"]], "_", motif, "$q3_signal_name <<- q3_signal_name")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("records$", gene[["name"]], "_", motif, "$q4_signal_name <<- q4_signal_name")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        # Save filepaths for parsed signal objects
        q1_signal_path <- paste0(dir_list$sigs, gene[["name"]], "_", motif, "_wg_Q1_signals.RData")
        q2_signal_path <- paste0(dir_list$sigs, gene[["name"]], "_", motif, "_wg_Q2_signals.RData")
        q3_signal_path <- paste0(dir_list$sigs, gene[["name"]], "_", motif, "_wg_Q3_signals.RData")
        q4_signal_path <- paste0(dir_list$sigs, gene[["name"]], "_", motif, "_wg_Q4_signals.RData")
        command <- paste0("records$", gene[["name"]], "_", motif, "$q1_signal_path <<- q1_signal_path")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("records$", gene[["name"]], "_", motif, "$q2_signal_path <<- q2_signal_path")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("records$", gene[["name"]], "_", motif, "$q3_signal_path <<- q3_signal_path")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("records$", gene[["name"]], "_", motif, "$q4_signal_path <<- q4_signal_path")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        # Save filepaths for parsed footprint graphs 
        q1_fp_path <- paste0(dir_list$graphs , gene[["name"]], "_", motif, "_wg_q1.svg")
        q2_fp_path <- paste0(dir_list$graphs , gene[["name"]], "_", motif, "_wg_q2.svg")
        q3_fp_path <- paste0(dir_list$graphs , gene[["name"]], "_", motif, "_wg_q3.svg")
        q4_fp_path <- paste0(dir_list$graphs , gene[["name"]], "_", motif, "_wg_q4.svg")
        command <- paste0("records$", gene[["name"]], "_", motif, "$graph_wg_q1_path <<- q1_fp_path")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("records$", gene[["name"]], "_", motif, "$graph_wg_q2_path <<- q2_fp_path")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("records$", gene[["name"]], "_", motif, "$graph_wg_q3_path <<- q3_fp_path")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("records$", gene[["name"]], "_", motif, "$graph_wg_q4_path <<- q4_fp_path")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        #### end ####
        
      } # end for (motif in names(item[["matrix"]]))
    } # end if (item[["haspwm"]] == TRUE)
  } # end for (item in gene_info[["genes"]])
#### end ####
} # end setVars function

getMotifPWM <- function(symbol)
{
  
  #### Reporting ####
  cat(black$bold(bgWhite("getMotifPWM current input argument:",
                         (red$bold(symbol)),
                         "\n"
                       )))
  #### end ####
  
  #### Query MotifDb ####
  # Define string to return only Hsapiens motifs
  organism_rows = grep('Hsapiens', values(MotifDb)$organism, ignore.case = TRUE)
  # Define string for given gene
  gene_symbol_rows = grep(symbol, values(MotifDb)$geneSymbol, ignore.case = TRUE)
  # Get indices for the intersection of gene and organism
  human_gene_rows = intersect(gene_symbol_rows, organism_rows)
  # Pull the PWMs
  # need to make it a list to use unique() function to remove duplicate entries
  gene_motifs <- as.list(MotifDb[human_gene_rows])
  # Get unique motifs
  unique_gene_motifs <- unique(gene_motifs)
  # Get number of motifs
  number_unique_gene_motifs <- length(unique_gene_motifs)
  #### end ####
  
  #### Reporting ####
  # total motifs found
  cat(black$bold(bgWhite("Number of motifs found in database:",
                         (red$bold(length(gene_motifs))),
                         "\n"
                       )))

  # unique motifs found
  cat(black$bold(bgWhite("Number of unique motifs:",
                       (red$bold(length(unique_gene_motifs))),
                       "\n",
                       "\n"
                       )))
  #### end ####
  
  #### Return PWM ####
  # Make a vector containing all the motifs
  unique_gene_motifs.vector <- c()
  for (a in 1:number_unique_gene_motifs) {
    unique_gene_motifs.vector[a] <- unique_gene_motifs[a]
  }
  
  # return the vector
  return(unique_gene_motifs.vector)
  #### end ####
  
  } # end getMotifPWM function

fileCheck <- function(filepath){
  ## Check for file at argument path
  ## Return TRUE if file exists
  ## Return FALSE if file does not exist
  cat("Checking for file...","\n")
  if (file.exists(filepath) == TRUE){ 
      cat(white$bgBlue$bold("File exists at path:", red(filepath), "\n"))
      return(TRUE)
    }else if (file.exists(filepath) == FALSE){
      cat(white$bgBlue$bold("File not found at path:", red(filepath), "\n"))
      return(FALSE)
    } # end if statement
  } # end fileCheck function

generateSignal <- function(reference, PWM, name, type, fp_path, sites){
  svg(filename = fp_path) # set the SVG options
  ## Generate the signal
  if(missing(sites)){ # Generate signal with no input binding sites
    cat("binding sites are missing", "\n")
    signal <- factorFootprints(
                              bamfiles = reference$bam_filepath, # bam file input
                              index = reference$bai_filepath, # bai index input
                              pfm = PWM, # PWM input
                              genome = reference$genome, # reference genome
                              min.score = reference$motif_score, # minimum motif matching score
                              seqlev = reference$scope, # scope of analysis
                              upstream = reference$upstream, # bp upstream of motif to analyze
                              downstream = reference$downstream # bp downstream of motif to analyze
                              )
    } else { # Generate signal with input binding sites
      cat("binding sites are present", "\n")
      signal <<- factorFootprints(
                                  bamfiles = reference$bam_filepath, # bam file input
                                  index = reference$bai_filepath, # bai index input
                                  pfm = PWM, # PWM input
                                  genome = reference$genome, # reference genome
                                  min.score = reference$motif_score, # minimum motif matching score
                                  seqlev = reference$scope, # scope of analysis
                                  upstream = reference$upstream, # bp upstream of motif to analyze
                                  downstream = reference$downstream, # bp downstream of motif to analyze
                                  bindingSites = sites # binding sites
                                  )
    
    } # End generate the signal
  ## Close the plot
  dev.off()
  return(signal)
} # end generateSignal function

parseSignals <- function(signals, mode, number){
  if (mode == "Q"){ # Quantile-based parsing
    cat("Parsing signals object in quantile mode...","\n")
    if (number == "FULL"){num_entries <- length(signals[["signal"]][["+"]][,1]) # number of entries to parse
    }else{num_entries = number}
    num_bp <- length(signals[["signal"]][["+"]][1,]) 
    motif_width <- (num_bp - 200) # number of basepairs in the motif (assume 100 up/down stream used)
    cat(num_entries,"total entries","\n", num_bp,"bp in signal matrix","\n", motif_width,"width of motif","\n")
    
    if (ts == TRUE){cat("Initializing calculation matrix", "\n")}
    calc_matrix <- matrix(data = NA, num_entries, 4) # matrix to store signal calculations
    colnames(calc_matrix) <- c("index","total","motif","ratio")
  
    ## Perform the matrix calculations
    if (ts == TRUE){cat("Performing matrix calculations", "\n")}
    for (a in 1:num_entries){
      calc_matrix[a,"index"] <- a
      calc_matrix[a,"total"] <- (sum(signals[["signal"]][["+"]][a,]) + sum(signals[["signal"]][["-"]][a,]))
      calc_matrix[a,"motif"] <- (sum(signals[["signal"]][["+"]][a,100:100+motif_width]) + sum(signals[["signal"]][["-"]][a,100:100+motif_width]))
    calc_matrix[a,"ratio"] <- (calc_matrix[a,"motif"] / calc_matrix[a,"total"])
    #if (ts == TRUE){cat("Index: ", a, "\n", "Total: ", calc_matrix[a,"total"], "\n", "Motif: ", calc_matrix[a,"motif"], "\n", "Ratio: ", calc_matrix[a,"ratio"], "\n")}
    } # End matrix calculations
    
    ## Remove sites with 0 total signal
    if (ts == TRUE){cat("Finding sites with < 5 total signal", "\n")}
    zero <- which(calc_matrix[,2] <= 5)
    if (length(zero) == 0){cat("No <5 signal entries found", "\n")} else {
    if (ts == TRUE){cat("Removing sites with less than 5 total signal", "\n")}
    calc_matrix <- calc_matrix[-zero,]}
    # get the number of non-zero entries
    num_nz_entries <- length(calc_matrix[,"total"])
    cat("Number of entries remaining:", num_nz_entries, "\n")
    
    ## Get the quantiles
    if (ts == TRUE){cat("Finding quartiles", "\n")}
    tq <- quantile(calc_matrix[,"total"], na.rm = TRUE) # total signal quantiles
    mq <- quantile(calc_matrix[,"motif"], na.rm = TRUE) # motif signal quantiles
    rq <- quantile(calc_matrix[,"ratio"], na.rm = TRUE) # ratio signal quantiles
    cat("Total signal: ", tq, "\n", "Motif signal: ", mq, "\n", "Ratio signal: ", rq, "\n")
  
    ## Get indices of the four quartiles
    if (ts == TRUE){cat("Populating quartile index list", "\n")}
    index_list <- list()
    index_list$q1 <- c(calc_matrix[which(calc_matrix[,"total"] >= tq[1] & calc_matrix[,"total"] < tq[2] ),"index"])
    index_list$q2 <- c(calc_matrix[which(calc_matrix[,"total"] >= tq[2] & calc_matrix[,"total"] < tq[3] ),"index"])
    index_list$q3 <- c(calc_matrix[which(calc_matrix[,"total"] >= tq[3] & calc_matrix[,"total"] < tq[4] ),"index"])
    index_list$q4 <- c(calc_matrix[which(calc_matrix[,"total"] >= tq[4] & calc_matrix[,"total"] <= tq[5] ),"index"])
    
    ## Generate the parsed binding sites objects
    if (ts == TRUE){cat("Generating parsed binding sites objects", "\n")}
    parsed_sites <- list() # Initiate the list
    binding_sites <- signals[["bindingSites"]] # Subset out the binding sites
    # Populate the list
    if (ts == TRUE){cat("Populating parsed bindingSites list", "\n")}
    parsed_sites$q1 <- binding_sites[index_list$q1]
    parsed_sites$q2 <- binding_sites[index_list$q2]
    parsed_sites$q3 <- binding_sites[index_list$q3]
    parsed_sites$q4 <- binding_sites[index_list$q4]
    parsed_sites$indexlist <- index_list # Include the index list for record keeping
    parsed_sites$tq <- tq
    parsed_sites$mq <- mq
    parsed_sites$rq <- rq
    parsed_sites$calc_matrix <- calc_matrix
    return(parsed_sites)
    } # End Quantile-based parsing
} # end parseSignals function

runPipeline <- function(dir, gene, reference, option, sites)
{
  ## This function will receive the dir list, gene_info list, reference parameters list, and thresholds list
  ## as arguments and will run the rest of the pipeline automatically, creating checkpoints by saving results
  ## to the disk and checking for their existence prior to performing any given operation
  # Perform initial gc()
  gc()
  
  if (ts == TRUE){cat("Iterating over all genes", "\n")}
  for (item in gene_info[["genes"]]){ # Iterate over all genes in list
    if (ts == TRUE){cat("Checking PWM", "\n")}
    if (item[["haspwm"]] == TRUE){  # Check that the gene has any PWMs from MotifDB
      if (ts == TRUE){cat("Iterating over all unique motifs", "\n")}
      for (motif in names(item[["matrix"]])){ # Iterate over all unique motifs for current gene
        
        #### Recover object names and filepaths from records list ####
        if (ts == TRUE){cat("Recovering object names and filepaths", "\n")}
        command <- paste0("signal_name <- records$", item[["name"]], "_", motif, '[["signal_name"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("signal_path <- records$", item[["name"]], "_", motif, '[["signal_path"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("fp_path <- records$", item[["name"]], "_", motif, '[["graph_wg_path"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("sites_name <- records$", item[["name"]], "_", motif, '[["sites_name"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("sites_path <- records$", item[["name"]], "_", motif, '[["sites_path"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        cat(signal_name, "\n", signal_path, "\n", sites_name, "\n", sites_path, "\n", fp_path, "\n")
        # Parsed signals
        command <- paste0("q1_signal_name <- records$", item[["name"]], "_", motif, '[["q1_signal_name"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("q2_signal_name <- records$", item[["name"]], "_", motif, '[["q2_signal_name"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("q3_signal_name <- records$", item[["name"]], "_", motif, '[["q3_signal_name"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("q4_signal_name <- records$", item[["name"]], "_", motif, '[["q4_signal_name"]]')
        # Parsed signal filepaths
        command <- paste0("q1_signal_path <- records$", item[["name"]], "_", motif, '[["q1_signal_path"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("q2_signal_path <- records$", item[["name"]], "_", motif, '[["q2_signal_path"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("q3_signal_path <- records$", item[["name"]], "_", motif, '[["q3_signal_path"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("q4_signal_path <- records$", item[["name"]], "_", motif, '[["q4_signal_path"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        # Parsed fp graph filepaths
        command <- paste0("q1_fp_path <- records$", item[["name"]], "_", motif, '[["graph_wg_q1_path"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("q2_fp_path <- records$", item[["name"]], "_", motif, '[["graph_wg_q2_path"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("q3_fp_path <- records$", item[["name"]], "_", motif, '[["graph_wg_q3_path"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("q4_fp_path <- records$", item[["name"]], "_", motif, '[["graph_wg_q4_path"]]')
        eval(parse(text = command, keep.source = getOption("keep.source")))
        #### end ####
  
        if (ts == TRUE){cat("Performing signal filecheck", "\n")}
        if (fileCheck(signal_path) == FALSE){ # If signal file does not exist on disk, create and save it
          
        #### SIGNALS #####
          cat("Signal file does not exist. generating...", "\n")
          if (missing(sites)){ # Generate signals, no binding sites supplied
            cat("Processing signal with no specified binding sites...", "\n")
            ## Generate and save the signals
            assign(signal_name, generateSignal(
                                            reference = reference_parameters,
                                            PWM = item[["matrix"]][[motif]],
                                            name = paste0(item[["name"]], "_", motif),
                                            type = "hg38",
                                            fp_path = fp_path)) 
            } else { # Generate signals when binding sites are supplied
            cat("Processing signal with specific binding sites", "\n")
            ## Generate and save the signals
            assign(signal_name, generateSignal(
                                            reference = reference_parameters,
                                            PWM = item[["matrix"]][[motif]],
                                            name = paste0(item[["name"]], "_", motif),
                                            type = "hg38",
                                            fp_path = fp_path,
                                            sites = sites))
            } # End generate signals
          
        ## Save the signal object to disk
        ## Use the eval/parse construct to simplify referencing the signal object
        if (ts == TRUE){cat("Saving signal object", "\n")}
        command <- paste0("save(", signal_name, ", ", "file = signal_path)")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        ## Add number of sites used to generate graph to records list
        if (ts == TRUE){cat("Adding number of sites found to record", "\n")}
        command <- paste0("num_sites <- length(", signal_name, "[['signal']][['+']][,1])")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        command <- paste0("records$", item[["name"]], "_", motif, "$num_sites_wg <<- num_sites")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        #### end ####
        
        #### BINDING SITES ####
        ## Pull the binding sites from the signal object and save to disk
        if (ts == TRUE){cat("Saving binding sites object to disk", "\n")}
        if (fileCheck(sites_path) == FALSE){ # Check if sites file exists
          cat("No binding sites file found on disk. Saving...", "\n")
          # Assign and save sites to disk
          command <- paste0("assign(sites_name, ", signal_name, "[['bindingSites']])")
          eval(parse(text = command, keep.source = getOption("keep.source")))
          command <- paste0("save(", sites_name, ", ", "file = sites_path)")
          eval(parse(text = command, keep.source = getOption("keep.source")))
        } else { 
          cat("sites file exists, skipping", "\n")}
        #### end ####

        #### PARSED ####
        # Parse the current signal object
        if (option$parse == TRUE){
          if (ts == TRUE){cat("Starting parse operations", "\n")}
          command <- paste0("parsed <- parseSignals(" , signal_name, ", option$parse_type, option$parse_num)")
          eval(parse(text = command, keep.source = getOption("keep.source")))
          # Save parsed binding sites to disk
          if (ts == TRUE){cat("Saving parsed binding sites objects to disk", "\n")}
          command <- paste0("assign(q1_sites_name, ", parsed[["q1"]], ")")
          eval(parse(text = command, keep.source = getOption("keep.source")))
          command <- paste0("assign(q2_sites_name, ", parsed[["q2"]], ")")
          eval(parse(text = command, keep.source = getOption("keep.source")))
          command <- paste0("assign(q3_sites_name, ", parsed[["q3"]], ")")
          eval(parse(text = command, keep.source = getOption("keep.source")))
          command <- paste0("assign(q4_sites_name, ", parsed[["q4"]], ")")
          eval(parse(text = command, keep.source = getOption("keep.source")))
          command <- paste0("save(", q1_sites_name, ", ", "file = q1_sites_path)")
          eval(parse(text = command, keep.source = getOption("keep.source")))
          command <- paste0("save(", q2_sites_name, ", ", "file = q2_sites_path)")
          eval(parse(text = command, keep.source = getOption("keep.source")))
          command <- paste0("save(", q3_sites_name, ", ", "file = q3_sites_path)")
          eval(parse(text = command, keep.source = getOption("keep.source")))
          command <- paste0("save(", q4_sites_name, ", ", "file = q4_sites_path)")
          eval(parse(text = command, keep.source = getOption("keep.source")))
          # Generate parsed signal objects, graphs, save both to disk 
          if (ts == TRUE){cat("Generating quantile parsed signal objects and graphs", "\n")}
          cat("Generating Q1 footprint graph", "\n")
          assign(q1_signal_name, generateSignal(
                                            reference = reference_parameters,
                                            PWM = item[["matrix"]][[motif]],
                                            name = paste0(item[["name"]], "_", motif),
                                            type = "hg38",
                                            fp_path = q1_fp_path,
                                            sites = parsed$q1))
          #
          cat("Generating Q2 footprint graph", "\n")
          assign(q2_signal_name, generateSignal(
                                            reference = reference_parameters,
                                            PWM = item[["matrix"]][[motif]],
                                            name = paste0(item[["name"]], "_", motif),
                                            type = "hg38",
                                            fp_path = q2_fp_path,
                                            sites = parsed$q2))
          #
          cat("Generating Q3 footprint graph", "\n")
          assign(q3_signal_name, generateSignal(
                                            reference = reference_parameters,
                                            PWM = item[["matrix"]][[motif]],
                                            name = paste0(item[["name"]], "_", motif),
                                            type = "hg38",
                                            fp_path = q3_fp_path,
                                            sites = parsed$q3))
          #
          cat("Generating Q4 footprint graph", "\n")
          assign(q4_signal_name, generateSignal(
                                            reference = reference_parameters,
                                            PWM = item[["matrix"]][[motif]],
                                            name = paste0(item[["name"]], "_", motif),
                                            type = "hg38",
                                            fp_path = q4_fp_path,
                                            sites = parsed$q4))
          # Save the parsed signal objects to disk
          if (ts == TRUE){cat("Saving parsed signal objects to disk", "\n")}
          command <- paste0("save(", q1_signal_name, ", ", "file = q1_signal_path)")
          eval(parse(text = command, keep.source = getOption("keep.source")))
          command <- paste0("save(", q2_signal_name, ", ", "file = q2_signal_path)")
          eval(parse(text = command, keep.source = getOption("keep.source")))
          command <- paste0("save(", q3_signal_name, ", ", "file = q3_signal_path)")
          eval(parse(text = command, keep.source = getOption("keep.source")))
          command <- paste0("save(", q4_signal_name, ", ", "file = q4_signal_path)")
          eval(parse(text = command, keep.source = getOption("keep.source")))
        } # End if (option$parse == TRUE)
        #### end ####

        #### CLEANUP ####
        if (ts == TRUE){cat("Clearing workspace and memory", "\n")}
        command <- paste0("rm(", signal_name, ",", sites_name, ",", q1_signal_name, ",", q2_signal_name, ",", q3_signal_name, ",", q4_signal_name, ",", q1_sites_name, ",", q2_sites_name, ",", q3_sites_name, ",", q4_sites_name, ")")
        eval(parse(text = command, keep.source = getOption("keep.source")))
        gc()
        #### end ####
        
        } else { # If the signal file already exists on disk, skip to next operation
        cat("Signal file exists. skipping to next operation...", "\n")} # End signal filecheck
      } # end for (motif in names(item[["matrix"]]))
    } # end if (item[["haspwm"]] == TRUE)
  } # end for (item in gene_info[["genes"]])
  # save the records object
  save(records, file = records$records_path)
} # end runPipeline function

pwm2pfm <- function(pfm, name="motif"){
    if(!all(round(colSums(pfm), digits=4)==1)){
      return(NULL)
    }
    new("pfm", mat=as.matrix(pfm), name=name)
    }

makeProfile <- function(sites, PWM, type){
  
  anchor <- c("cut site")
  pfm <- PWM  
  min.score <- motif_score
  bindingSites <- sites
  seqlev <- scope
  bamfiles <- bampath
  index <- baipath

      stopifnot(is(bindingSites, "GRanges"))
      stopifnot(all(!is.na(seqlengths(bindingSites))))
      stopifnot(length(bindingSites)>1)
      stopifnot(length(bindingSites$score)==length(bindingSites))
      mt <- bindingSites
      mt$userdefined <- TRUE
  
  wid <- ncol(pfm)
  seqlevels(mt) <- seqlev
  seqinfo(mt) <- Seqinfo(seqlev, seqlengths = seqlengths(mt))
  
  ## read in bam file with input seqlev specified by users
  which <- as(seqinfo(mt), "GRanges")
  param <- ScanBamParam(which=which)
  if(anchor=="cut site"){
    bamIn <- mapply(function(.b, .i) readGAlignments(.b, .i, param = param), 
                    bamfiles, index, SIMPLIFY = FALSE)
  }else{
    bamIn <- mapply(function(.b, .i) readGAlignmentPairs(.b, .i, param = param), 
                    bamfiles, index, SIMPLIFY = FALSE)
  }
  
  ##
  bamIn <- lapply(bamIn, as, Class = "GRanges")
  if(!is(bamIn, "GRangesList")) bamIn <- GRangesList(bamIn)
  bamIn <- unlist(bamIn)
  seqlevelsStyle(bamIn) <- seqlevelsStyle(genome)
  if(anchor=="cut site"){
    ## keep 5'end as cutting sites
    bamIn <- promoters(bamIn, upstream=0, downstream=1)
  }else{
    ## keep fragment center
    bamIn <- reCenterPeaks(bamIn, width=1)
  }
  
  ##
  libSize <- length(bamIn)
  coverageSize <- sum(as.numeric(width(reduce(bamIn, ignore.strand=TRUE))))
  libFactor <- libSize / coverageSize
  
  
  ## split into positive strand and negative strand
  bamIn <- split(bamIn, strand(bamIn))
 
  
  ## get coverage
  cvglist <- sapply(bamIn, coverage)
  cvglist <- cvglist[c("+", "-")]
  cvglist <- lapply(cvglist, function(.ele)
    .ele[names(.ele) %in% seqlev])
  
  ## coverage of mt, must be filtered, otherwise too much
  cvgSum <- cvglist[["+"]] + cvglist[["-"]]
  mt.s <- split(mt, seqnames(mt))
  seqlev <- intersect(names(cvgSum), names(mt.s))
  cvgSum <- cvgSum[seqlev]
  mt.s <- mt.s[seqlev]
  
  ## too much if use upstream and downstream, just use 3*wid maybe better.
  mt.s.ext <- promoters(mt.s, upstream=wid, downstream=wid+wid)
  stopifnot(all(lengths(mt.s.ext)==lengths(mt.s)))
  mt.v <- Views(cvgSum, mt.s.ext)
  mt.s <- mt.s[viewSums(mt.v)>0] 
  mt <- unlist(mt.s)
  mt.ids <- promoters(reCenterPeaks(mt, width=1),
                      upstream=upstream+floor(wid/2),
                      downstream=downstream+ceiling(wid/2)+1)
  mt.ids <- paste0(as.character(seqnames(mt.ids)), ":", start(mt.ids), "-", end(mt.ids))
  sigs <- featureAlignedSignal(cvglists=cvglist,
                              feature.gr=reCenterPeaks(mt, width=1),
                              upstream=upstream+floor(wid/2),
                              downstream=downstream+ceiling(wid/2),
                              n.tile=upstream+downstream+wid)
  mt <- mt[match(rownames(sigs[[1]]), mt.ids)]
  cor <- lapply(sigs, function(sig){
      sig.colMeans <- colMeans(sig)
      ## calculate correlation of footprinting and binding score
      windows <- slidingWindows(IRanges(1, ncol(sig)), width = wid, step = 1)[[1]]
      # remove the windows with overlaps of motif binding region
      windows <- windows[end(windows)<=upstream | start(windows)>=upstream+wid]
      sig.windowMeans <- viewMeans(Views(sig.colMeans, windows))
      windows.sel <- windows[which.max(sig.windowMeans)][1]
      highest.sig.windows <- 
          rowMeans(sig[, start(windows.sel):end(windows.sel)])
      predictedBindingSiteScore <- mt$score
      if(length(predictedBindingSiteScore) == length(highest.sig.windows)){
        suppressWarnings({
          cor <- cor.test(x = predictedBindingSiteScore, 
                          y = highest.sig.windows, 
                          method = "spearman")
        })
      }else{
        cor <- NA
      }
      cor
  })
  
  ###########################################################
  ## This is where you can insert the shuffled signals ######
  sigs <- lapply(sigs, function(.ele) .ele[mt$userdefined, ])
  ## Make the null model
  if (type == "nullmodel"){
  nums <- nrow(sigs[["+"]])
  cols <- ncol(sigs[["+"]])
  plusshuf <- matrix(data=NA, nrow=nums, ncol=cols)
  minusshuf <- matrix(data=NA, nrow=nums, ncol=cols)
  for (c in 1:nums){
    plusshuf[c,] <- as.double(sample(sigs[["+"]][c,], replace=FALSE))
    minusshuf[c,] <- as.double(sample(sigs[["-"]][c,], replace=FALSE))
  }
  sigs$"+" <- plusshuf
  sigs$"-" <- minusshuf
  }
  ###########################################################
  ###########################################################
  
  mt <- mt[mt$userdefined]
  mt$userdefined <- NULL
  
  ## segmentation the signals
  ## x2 because stranded.
  Profile <- lapply(sigs, function(.ele) colMeans(.ele, na.rm = TRUE)*2/libFactor)
  ## upstream + wid + downstream
  Profile.split <- lapply(Profile, function(.ele){
    list(upstream=.ele[seq.int(upstream)],
         binding=.ele[upstream+seq.int(wid)],
         downstream=.ele[upstream+wid+seq.int(downstream)])
  })
  
  ##
  optimalSegmentation <- function(.ele){
    .l <- length(.ele)
    short_abun <- cumsum(.ele)/seq.int(.l)
    long_abun <- cumsum(rev(.ele))/seq.int(.l)
    long_abun <- rev(long_abun)
    short_abun <- short_abun[-length(short_abun)]
    long_abun <- long_abun[-1]
    ##long_abun should always greater than short_abun
    long_abun <- long_abun - short_abun
    long_abun[long_abun<0] <- 0
    cov_diff <- numeric(length(short_abun))
    for(i in seq_along(.ele)){
      cov_diff_tmp <- .ele
      cov_diff_tmp <- cov_diff_tmp-short_abun[i]
      cov_diff_tmp[-seq.int(i)] <- cov_diff_tmp[-seq.int(i)] - long_abun[i]
      cov_diff[i] <- mean(cov_diff_tmp^2)
    }
    .ids <- which(cov_diff==min(cov_diff, na.rm = TRUE))
    data.frame(pos=.ids, short_abun=short_abun[.ids], long_abun=long_abun[.ids])
  }
  Profile.seg <- lapply(Profile.split, function(.ele){
    ups <- optimalSegmentation(.ele$upstream)
    downs <- optimalSegmentation(rev(.ele$downstream))
    ## find the nearest pair
    .min <- c(max(rbind(ups, downs)), 0, 0)
    for(i in seq.int(nrow(ups))){
      for(j in seq.int(nrow(downs))){
        tmp <- sum(abs(ups[i, -1] - downs[j, -1]))
        if(tmp < .min[1]){
          .min <- c(tmp, i, j)
        }
      }
    }
    c(colMeans(rbind(ups[.min[2], ], downs[.min[3], ])), binding=mean(.ele$binding, na.rm=TRUE))
  })
  
  ##
  Profile.seg <- colMeans(do.call(rbind, Profile.seg))
  Profile.seg[3] <- Profile.seg[2]+Profile.seg[3]
  names(Profile.seg)[2:3] <- c("distal_abun", "proximal_abun")
  
  pwm2pfm <- function(pfm, name="motif"){
  if(!all(round(colSums(pfm), digits=4)==1)){
    return(NULL)
  }
  new("pfm", mat=as.matrix(pfm), name=name)
}
  
  ## Input arguments for calling the plotFootprints function
  args <- list()
  args$Profile <- c(Profile[["+"]], Profile[["-"]])
  args$ylab <- ifelse(anchor=="cut site", "Cut-site probability", "reads density (arbitrary unit)")
  args$Mlen <- wid
  args$motif <- pwm2pfm(pfm)
  args$segmentation <- Profile.seg
  
  if (type == "nullmodel"){
  args$nullplus <- sigs$"+"
  args$nullminus <- sigs$"-"
  }
  
  return(args)
}

generateNullFP <- function(n, t, s, m){
#This script will be used to generate indiviudal null models at predicted motif binding sites across the genome when scanning for TF footprinting from ATAC-seq data. To generate these null models, the current model will need to:
#- Consider the total signal (number of insertions) at each specific ~200 bp locus
#- Use the actul underlying reference sequence of that ~200 bp stretch from the hg38 reference genome
#- Use published or experimentally derived models of Tn5 sequence specific insertion bias
#- For each locus, build a probablistic model of insertion site distributions based on the underlying sequence and Tn5 insertion bias
#- Generate the null model graph by weighted random residstribution of the total observed signal at that site
#- Importantly, the null model must be generated separately for the plus and minus strand, it can then be combined and compared to the combined signal from the reference observed signal at that sequence
#These null models can then be used for a site-by-site comparison of the null model against the observed data to accept or reject the null hypothesis
  
  # declare vector of size n to store average motif signal values
  averages <- c()

  # generate the null models and calculate motif averages
  for (a in 1:n){
    
    # declare the null vector
    null <- c(1:(s))
    
    # randomly distribute the total signal
    # size = the number of values to distribute
    # prob = probability of each site
    # length = length of the generated vector
    null <- c(as.vector(rmultinom(1, size=t, prob=rep(1, length(null)))))
    
    # calculate the average signal in the motif region
    b <- (s - 100 - m) # start of motif
    c <- (s - 100) # end of motif
    avg <- sum(null[b:c])
    avg <- (avg/m)

    # store the values
    averages[a] <- avg
    
    ### plotting
    # make the density plot
    # generate the density distribution
    # adjust can be modified to adjust the kernel estimation bandwidth
    #d <- density(averages, adjust=1, from=0)
    # make the plot
    # main can be specified to make a chart title
    # make the title string
    #title <- paste0("Motif signal means", "\n", "n = ", n, ", input signal = ", t, ", motif size = ", m)
    #plot(d, main=title)
    ## check for uniform distribution with QQ plot
    #qqplot(averages, runif(1000))
    #abline(0,1)

  } # end for (a in 1:n)
  return(averages)
} # end generateNullFP function

makeTestRanges <- function(){
  testRanges <<- GRanges(seqnames = c(paste0("chr", c(1:22, "X", "Y"))),
                    ranges = IRanges(start = rep(10000, times = 24), end = rep(10500, times = 24)),
                    strand = c(rep("+", times = 24)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = 24)))}

```


** Unfinished functions **
motifClust
```{r}
motifClust <- function(k, signals, num){
## Returns a vector with k clusters referenced by motif site index

if (num == "NULL"){num_sites <- length(signals[["signal"]][["+"]][,1])}else{num_sites <- num}
num_bp <- length(signals[["signal"]][["+"]][1,]) 
motif_width <- (num_bp - 200) # number of basepairs in the motif (assume 100 up/down stream used)
cat("Number of sites: ", num_sites, "\n", "Number of bp in each site: ", num_bp, "\n", "Width of motif: ", motif_width, "\n")

## Add plus and minus strand signals
if (ts == TRUE){cat("Generating signal matrix", "\n")}
plus <- signals[["signal"]][["+"]]
minus <- signals[["signal"]][["-"]]
signal_matrix <- matrix(data = NA, nrow = num_sites, ncol = num_bp)
for (a in 1:num_sites){
  for (b in 1:num_bp){
    signal_matrix[a,b] <- (plus[a,b] + minus[a,b])}}


#### Ward Hierarchical Clustering ####
clustin <- signal_matrix
clustin <- scale(clustin) # standardize variables
d <- dist(clustin, method = "euclidean") # distance matrix
fit <- hclust(d, method="ward.D") 
groups <- cutree(fit, k=k) # cut tree into k clusters
plot(fit, type="c") # display dendogram
rect.hclust(fit, k=k, border="red") # draw dendogram with red borders around the k clusters 
return(groups)
#### end ####

 
Model Based Clustering
 
 fit <- Mclust(clustin)
 plot(fit) # plot results 
 summary(fit) # display the best model

 for (a in 1:num){
   for (b in 1:num){
     
     m1 <- signal[["+"]][a,]
     m2 <- signal[["+"]][b,]
     
     correlations[a,b] <- motifCorr(m1,m2)
     
     
   } # end for (b in 1:100)
 } # end for (a in 1:100)


} # end clusterMotif function

```

test motifClust
```{r}

clu <- motifClust(7, ASCL2_motif1_genome_signals, 1000)

```

motifCorr
```{r}
 motifCorr <- function(motif1, motif2){

   # initialize matrix
   cmatrix <- matrix(data=NA, nrow=3, ncol=length(motif1))
   # add values to matrix
   for (a in 1:length(motif1)){
     cmatrix[1,a] <- c(motif1[a])
     cmatrix[2,a] <- c(motif2[a])
     motif1_total <- sum(motif1)
     motif2_total <- sum(motif2)
     cmatrix[3,a] <- abs(cmatrix[1,a]-cmatrix[2,a])
   } # end for (a in 1:motif)

   diff <- as.integer(sum(cmatrix[3,]))
   total <- motif1_total+motif2_total
   norm <- diff/total
   #cat("sum of differences:", diff, "\n")
   #cat("total signal", total, "\n")
   #cat("normalized", norm, "\n")
   return(diff)
 } # end motifCorr

 correlations<-melt(correlations)
 correlations<-correlations[correlations$value!=0,]

 ggplot(correlations, aes(x = Var2, y = Var1)) +
   geom_raster(aes(fill=value)) +
   scale_fill_gradient(low="grey90", high="red") +
   labs(x="letters", y="LETTERS", title="Matrix") +
   theme_bw() + theme(axis.text.x=NULL,
                      axis.text.y=NULL,
                      plot.title=element_text(size=11))

 set.seed(2)
 o <- seriate(correlations, method="BEA_TSP")

 longData<-melt(correlations)
 longData<-longData[longData$value!=0,]

 #with the same longData then earlier
 longData$Var1 <- factor(longData$Var1, levels=names(unlist(o[[1]][])))
 longData$Var2 <- factor(longData$Var2, levels=names(unlist(o[[2]][])))
 #levels must be names

 ggplot(longData, aes(x = Var2, y = Var1)) +
   geom_raster(aes(fill=value)) +
   scale_fill_gradient(low="grey90", high="red") +
   labs(x="letters", y="LETTERS", title="Matrix") +
   theme_bw() + theme(axis.text.x=element_text(size=9, angle=0, vjust=0.3),
                      axis.text.y=element_text(size=9),
                      plot.title=element_text(size=11))
}
```

Retrieve underlying sequences for all motif sites
```{r}
genome <- Hsapiens
gr <- H508_WT_01_CDX2_motif1_wg_signals[["bindingSites"]]
# subset for a quick run
gr <- gr[1:1000]

## Expand the Granges windows to 200 bp on either side of motif
for (a in 1:length(gr)){
    gr[a]@ranges@start <- as.integer(gr[a]@ranges@start - 200)
    #gr[a]@ranges@width <- as.integer(gr[a]@ranges@width + 400)
    }

# getSeq(ref genome, granges), retrieves sequences associated with the Granges sites
seqs <- getSeq(genome, gr, as.character = TRUE)


```

Generate FP heatmaps
```{r}

generateFPHeatmaps <- function(fullpaths, filenames){
  
  ## Get the number of files in the list
  numfiles <- length(filenames) # Get the number of inputs
  
  ## Iterate over all filenames
  for (a in 4:numfiles){
    
    #### Cleanup memory at each iteration ####
    cat(fullpaths[a])
    gc()
    #### end ####
    
    #### Load the signal object into workspace ####
    insig <- load(fullpaths[a])
    signals <- get(insig)
    
    ## Get the total number of entries in the signals
    num_entries <- length(signals[["signal"]][["+"]][,1]) # number of entries to parse
    ## Get the gene name and motif number index
    curfile <- filenames[a]
    # Get the gene name
    re <- regexpr("(^[A-Z1-9]*)", curfile, perl=TRUE)
    gene <- regmatches(curfile, re)
    # Get the motif index
    re <- regexpr("motif([1-9])_", curfile, perl=TRUE)
    mindex <- regmatches(curfile, re)
    re <- regexpr("[1-9]", mindex, perl=TRUE)
    mindex <- as.integer(regmatches(mindex, re))
    ## get the PWM
    PWM <- getMotifPWM(gene)
    PWM <- PWM[[mindex]]
    ## Width of the motif
    motif_width <- length(PWM[1,])
    numbp <- motif_width + upstream + downstream
    #### end ####
    
    #### Make the calculations matrix and subset to top 1000 ####
    calc_matrix <- matrix(data = NA, num_entries, 4) # matrix to store signal calculations
    colnames(calc_matrix) <- c("index","total","motif","ratio")
  
    ## Perform the matrix calculations
    for (b in 1:num_entries){
      calc_matrix[b,"index"] <- b
      calc_matrix[b,"total"] <- (sum(signals[["signal"]][["+"]][b,]) + sum(signals[["signal"]][["-"]][b,]))
      calc_matrix[b,"motif"] <- (sum(signals[["signal"]][["+"]][b,100:100+motif_width]) + sum(signals[["signal"]][["-"]][b,100:100+motif_width]))
      calc_matrix[b,"ratio"] <- (calc_matrix[b,"motif"] / calc_matrix[b,"total"])
    } # End matrix calculations

    ## Find the top 1000 total signal rows
    # sort the matrix by total signal
    sorted <- calc_matrix[order(calc_matrix[,"total"], decreasing = TRUE),]
    # get index of top 1000
    ind <- sorted[1:1000,"index"]

    ## Get the Granges to make the new FP graph
    gr <- signals[["bindingSites"]][ind]
    #### end ####
    
    #### Construct the filepaths for saving the svg files ####
    ## For FP graph
    savepath_fp <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_fp <- gsub("_wg_", "_top_", savepath_fp)
    savepath_fp <- gsub(".RData", "_fp.svg", savepath_fp)
    ## For heatmap
    savepath_heatmap <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_heatmap <- gsub("_wg_", "_top_", savepath_heatmap)
    savepath_heatmap <- gsub(".RData", "_heatmap.svg", savepath_heatmap)
    ## For FP null
    savepath_fp_null <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_fp_null <- gsub("_wg_", "_top_null_", savepath_fp_null)
    savepath_fp_null <- gsub(".RData", "_fp.svg", savepath_fp_null)
    ## For heatmap null
    savepath_heatmap_null <- gsub("sigs", "heatmaps", fullpaths[a])
    savepath_heatmap_null <- gsub("_wg_", "_top_", savepath_heatmap_null)
    savepath_heatmap_null <- gsub(".RData", "_null_heatmap.svg", savepath_heatmap_null)
    #### end ####
    
    #### Make the new graphs ####
    #
    sigs <- list()
    #sigs$signal[["+"]] <- (signals[["signal"]][["+"]][ind,]+signals[["signal"]][["-"]][ind,])
    sigs$signal[["+"]] <- (signals[["signal"]][["+"]][ind,])
    sigs$signal[["-"]] <- (signals[["signal"]][["-"]][ind,])
    
    ## FP graph
    prof <- makeProfile(gr, PWM, "normal")
    
    pwm2pfm <- function(pfm, name="motif"){
    if(!all(round(colSums(pfm), digits=4)==1)){
      return(NULL)
    }
    new("pfm", mat=as.matrix(pfm), name=name)
    }
    PWMin <- pwm2pfm(PWM)
    #
    svg(file = savepath_fp) # set the filepath for saving the svg figure
    ATACseqQC:::plotFootprints(prof$Profile,
                               Mlen=motif_width, motif=PWMin)
    dev.off()
    
    ## Heatmap graph
    svg(file = savepath_heatmap) 
    featureAlignedHeatmap(sigs$signal, 
                      feature.gr=reCenterPeaks(gr,
                                               width=numbp), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=numbp)
    dev.off()
    
    ## FP NULL graph
    prof <- makeProfile(gr, PWM, "nullmodel")
    
    pwm2pfm <- function(pfm, name="motif"){
    if(!all(round(colSums(pfm), digits=4)==1)){
      return(NULL)
    }
    new("pfm", mat=as.matrix(pfm), name=name)
    }
    PWMin <- pwm2pfm(PWM)
    #
    svg(file = savepath_fp_null) # set the filepath for saving the svg figure
    ATACseqQC:::plotFootprints(prof$Profile,
                               Mlen=motif_width, motif=PWMin)
    dev.off()
    
    ## Heatmap NULL graph
    svg(file = savepath_heatmap_null)
    nullsig <- list()
    nullsig[["signal"]][["+"]] <- prof$nullplus
    nullsig[["signal"]][["-"]] <- prof$nullminus
    featureAlignedHeatmap(nullsig$signal, 
                      feature.gr=reCenterPeaks(gr,
                                               width=numbp), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=numbp)
    dev.off()
    
    
    #### end ####
    
  } # end for (a in 1:num){
} # end generateFPHeatmaps function
```

signalScanning
```{r}

#This script will be used to calculate ATAC-seq signals at all human genes from hg38
#it will scan windows including:

#1) total signal in 200 bp region upstream of genes
#2) total signal in 2000 bp region upstream of genes
#3) total signal in 200 bp upstream + gene
#4) total signal in 2000 bp upstream + gene
#5) total signal in gene only

#For each of these categories, it will then rank the genes by total signal

#This script references: https://biodatascience.github.io/compbio/bioc/ranges.html

#Copy the gene database
#### Setup ####
## perform gc
gc()

## Paths of bam, bai, genomic locations file
bam <- "/home/rstudio1/atac/h508/bam/h508_all_dedup.bam"
idx <- "/home/rstudio1/atac/h508/bam/h508_all_dedup.bam.bai"
textfile <- "/home/rstudio1/atac/h508/smad4_entrez_targets.txt"
con <- file(description=textfile, open="r")

## Copy list of ENTREZ target IDS from text file
smad4_targets <- c()
for (i in 1:7897){
  smad4_targets[i] <- scan(file=con, nlines=1, quiet=TRUE)
  
}
#### end ####

#### Copy info from ensembl database to make GRanges object ####
# copy the database and gene info
edb <- EnsDb.Hsapiens.v86
g <- genes(edb)
rm(edb)
# subset to only the standard chromosomes
g <- keepStandardChromosomes(g, pruning.mode="coarse")
#### end ####

#### Subset the granges object for specific targets ####
targets <- c(which(g@elementMetadata@listData[["entrezid"]] %in% smad4_targets))
g_smad4 <- g
# this metadata column is required to make the annot object
g_smad4@elementMetadata$id <- g_smad4@elementMetadata@listData[["gene_name"]]
#### end ####

#### initialize the modified granges objects ####
g_smad4_200up <- g_smad4
g_smad4_2000up <- g_smad4
g_smad4_200up_gene <- g_smad4
g_smad4_2000up_gene <- g_smad4
#### end ####

#### make the modified granges objects ####
for (a in 1:length(g_smad4)){
  
  ### change positive strand entries
  if (g_smad4[a]@strand@values == "+"){
    
    ### 200 bp upstream only
    g_smad4_200up[a]@ranges@start <- as.integer(g_smad4_200up[a]@ranges@start - 200)
    g_smad4_200up[a]@ranges@width <- as.integer(200)
    
    ### 2000 bp upstream only
    g_smad4_2000up[a]@ranges@start <- as.integer(g_smad4_2000up[a]@ranges@start - 2000)
    g_smad4_2000up[a]@ranges@width <- as.integer(2000)
    
    ### 200 bp upstream and gene
    g_smad4_200up_gene[a]@ranges@start <- as.integer(g_smad4_200up_gene[a]@ranges@start - 200)
    g_smad4_200up_gene[a]@ranges@width <- as.integer(g_smad4_200up_gene[a]@ranges@width + 200)
    
    ### 2000 bp upstream and gene
    g_smad4_2000up_gene[a]@ranges@start <- as.integer(g_smad4_2000up[a]@ranges@start - 2000)
    g_smad4_2000up_gene[a]@ranges@width <- as.integer(g_smad4_2000up_gene[a]@ranges@width + 2000)
    
  }
  ### change negative strand entries
  if (g_smad4[a]@strand@values == "-"){
    
    ### 200 bp upstream only
    g_smad4_200up[a]@ranges@start <- as.integer(g_smad4_200up[a]@ranges@start + g_smad4_200up[a]@ranges@width)
    g_smad4_200up[a]@ranges@width <- as.integer(200)
    
    ### 2000 bp upstream only
    g_smad4_2000up[a]@ranges@start <- as.integer(g_smad4_2000up[a]@ranges@start + g_smad4_2000up[a]@ranges@width)
    g_smad4_2000up[a]@ranges@width <- as.integer(2000)
    
    ### 200 bp upstream and gene
    g_smad4_200up_gene[a]@ranges@width <- as.integer(g_smad4_200up_gene[a]@ranges@width + 200)
    
    ### 2000 bp upstream and gene
    g_smad4_2000up_gene[a]@ranges@width <- as.integer(g_smad4_2000up_gene[a]@ranges@width + 2000)
  }
}
#### end ####

#### trim out of bounds ranges ####
## use GenomicRanges:::get_out_of_bound_index to find out of bounds ranges

idx <- GenomicRanges:::get_out_of_bound_index(g_smad4)
if (length(idx) != 0L)
    g_smad4 <- g_smad4[-idx]


idx <- GenomicRanges:::get_out_of_bound_index(g_smad4_200up)
if (length(idx) != 0L)
    g_smad4_200up <- g_smad4_200up[-idx]


idx <- GenomicRanges:::get_out_of_bound_index(g_smad4_2000up)
if (length(idx) != 0L)
    g_smad4_2000up <- g_smad4_2000up[-idx]


idx <- GenomicRanges:::get_out_of_bound_index(g_smad4_200up_gene)
if (length(idx) != 0L)
    g_smad4_200up_gene <- g_smad4_200up_gene[-idx]


idx <- GenomicRanges:::get_out_of_bound_index(g_smad4_2000up_gene)
if (length(idx) != 0L)
    g_smad4_2000up_gene <- g_smad4_2000up_gene[-idx]
#### end ####

#### workspace cleanup ####
close.connection(con=con)
#rm(g, i, smad4_targets, targets, textfile)
#### end ####


annot_gene <- createAnnotationFile(g_smad4)
annot_200up <- createAnnotationFile(g_smad4_200up)
annot_2000up <- createAnnotationFile(g_smad4_2000up)
annot_gene_200up <- createAnnotationFile(g_smad4_200up_gene)
annot_gene_2000up <- createAnnotationFile(g_smad4_2000up_gene)

## workspace cleanup
rm(g_smad4, g_smad4_2000up, g_smad4_200up, g_smad4_2000up_gene, g_smad4_200up_gene)


# run featureCounts
counts_gene <- featureCounts(
                        files=bam,
                        isPairedEnd=TRUE,
                        nthreads=8,
                        annot.ext=annot_gene)

counts_200up <- featureCounts(
                        files=bam,
                        isPairedEnd=TRUE,
                        nthreads=8,
                        annot.ext=annot_200up)

counts_2000up <- featureCounts(
                        files=bam,
                        isPairedEnd=TRUE,
                        nthreads=8,
                        annot.ext=annot_2000up)

counts_gene_200up <- featureCounts(
                        files=bam,
                        isPairedEnd=TRUE,
                        nthreads=8,
                        annot.ext=annot_gene_200up)

counts_gene_2000up <- featureCounts(
                        files=bam,
                        isPairedEnd=TRUE,
                        nthreads=8,
                        annot.ext=annot_gene_2000up)

### workspace cleanup
rm(annot_2000up, annot_200up, annot_gene, annot_gene_2000up, annot_gene_200up, a, bam, idx)



### quantiles
qnt_gene <- quantile(counts_gene[["counts"]])
qnt_200up <- quantile(counts_200up[["counts"]])
qnt_2000up <- quantile(counts_2000up[["counts"]])
qnt_gene_200up <- quantile(counts_gene_200up[["counts"]])
qnt_gene_2000up <- quantile(counts_gene_2000up[["counts"]])
###


### make basic plots
plot.default(x=counts_gene[["counts"]], y=NULL, ylab="READS GENE")
plot.default(x=counts_200up[["counts"]], y=NULL, ylab="READS 200UP")
plot.default(x=counts_2000up[["counts"]], y=NULL, ylab="READS 2000UP")
plot.default(x=counts_gene_200up[["counts"]], y=NULL, ylab="READS GENE AND 200UP")
plot.default(x=counts_gene_2000up[["counts"]], y=NULL, ylab="READS GENE AND 2000UP")
###



## copy the total signal to a matrix
signal_matrix <- matrix(data = NA, 56271, 5)
# apply column names to signal matrix
colnames(signal_matrix) <- c("gene", "200up", "2000up", "gene+200up", "gene+2000up")
# apply rownames to matrix
rownames(signal_matrix) <- c(counts_gene[["annotation"]][["GeneID"]])

# copy signal to matrix
for (c in 1:56271){
  signal_matrix[[c,"gene"]] <- as.integer(counts_gene[["counts"]][c])
  signal_matrix[[c,"200up"]] <- as.integer(counts_200up[["counts"]][c])
  signal_matrix[[c,"2000up"]] <- as.integer(counts_2000up[["counts"]][c])
  signal_matrix[[c,"gene+200up"]] <- as.integer(counts_gene_200up[["counts"]][c])
  signal_matrix[[c,"gene+2000up"]] <- as.integer(counts_gene_2000up[["counts"]][c])
}


df <- data.frame(
  "gene"=signal_matrix[,1],
  "200up"=signal_matrix[,2],
  "2000up"=signal_matrix[,3],
  "gene_200up"=signal_matrix[,4],
  "gene_2000up"=signal_matrix[,5]
  )



options(scipen=999)  # turn-off scientific notation like 1e+48


# Scatterplot
theme_set(theme_bw())  # pre-set the bw theme.
g <- ggplot(df, aes(gene, X200up))
g + geom_jitter(width = .5, size=1) +
  labs(y="200 bp upstream", 
       x="gene", 
       title="Read counts gene v 200 bp upstream")


# Scatterplot
theme_set(theme_bw())  # pre-set the bw theme.
g <- ggplot(df, aes(gene, X2000up))
g + geom_jitter(width = .5, size=1) +
  labs(y="2000 bp upstream", 
       x="gene", 
       title="Read counts gene v 2000 bp upstream")




```

plotFootprints
```{r}
plotFootprints <- function (Profile, Mlen = 0,
                            xlab = "Dist. to motif (bp)",
                            ylab = "Cut-site probability",
                            legTitle, xlim, ylim,
                            newpage = TRUE, motif, segmentation)
{
  stopifnot(is(motif, "pfm"))
  if(newpage) grid.newpage()

  S <- length(Profile)
  W <- ((S/2) - Mlen)/2
  vp <- plotViewport(margins=c(5.1, 5.1, 4.1, 2.1), name="plotRegion")
  pushViewport(vp)
  if(missing(xlim)){
    xlim <- c(0, S/2+1)
  }
  if(missing(ylim)){
    ylim <- c(0, max(Profile) * 1.12)
  }
  vp1 <- viewport(y=.4, height=.8,
                  xscale=xlim,
                  yscale=ylim,
                  name="footprints")
  pushViewport(vp1)
  grid.lines(x=1:(S/2),
             y=Profile[1:(S/2)],
             default.units="native",
             gp=gpar(lwd = 2, col = "darkblue"))
  grid.lines(x=1:(S/2),
             y=Profile[(S/2 + 1):S],
             default.units="native",
             gp=gpar(lwd = 2, col = "darkred"))
  if(!missing(segmentation)){
    if(length(segmentation)==4){
      ## plot the guide line for the segmentation
      grid.segments(x0=c(0, segmentation[1], W, W+Mlen, S/2-segmentation[1]),
                    x1=c(segmentation[1], W, W+Mlen, S/2-segmentation[1], S/2),
                    y0=c(segmentation[2], segmentation[3], segmentation[4], segmentation[3], segmentation[2]),
                    y1=c(segmentation[2], segmentation[3], segmentation[4], segmentation[3], segmentation[2]),
                    default.units = "native",
                    gp=gpar(lwd =2, col = "red", lty = 2))
    }
  }
  grid.xaxis(at = c(seq(1, W, length.out = 3),
                    W + seq(1, Mlen),
                    W + Mlen + seq(1, W, length.out = 3)),
             label = c(-(W + 1 - seq(1, W + 1, length.out = 3)),
                       rep("", Mlen),
                       seq(0, W, len = 3)))
  grid.yaxis()
  grid.lines(x=c(W, W, 0), y=c(0, max(Profile), ylim[2]),
             default.units="native", gp=gpar(lty=2))
  grid.lines(x=c(W + Mlen + 1, W + Mlen + 1, S/2),
             y=c(0, max(Profile), ylim[2]),
             default.units="native", gp=gpar(lty=2))
  upViewport()
  vp2 <- viewport(y=.9, height=.2,
                  xscale=c(0, S/2+1),
                  name="motif")
  pushViewport(vp2)
  motifStack::plotMotifLogoA(motif)
  upViewport()
  upViewport()
  grid.text(xlab, y=unit(1, 'lines'))
  grid.text(ylab, x=unit(1, 'line'), rot = 90)
  if(missing(legTitle)){
    legvp <- viewport(x=unit(1, "npc")-convertX(unit(1, "lines"), unitTo="npc"),
                      y=unit(1, "npc")-convertY(unit(1, "lines"), unitTo="npc"),
                      width=convertX(unit(14, "lines"), unitTo="npc"),
                      height=convertY(unit(3, "lines"), unitTo="npc"),
                      just=c("right", "top"), name="legendWraper")
    pushViewport(legvp)
    grid.legend(labels=c("For. strand", "Rev. strand"),
                gp=gpar(lwd=2, lty=1, col=c("darkblue", "darkred")))
    upViewport()
  } else {
    grid.text(legTitle,
              y=unit(1, "npc")-convertY(unit(1, "lines"), unitTo="npc"),
              gp=gpar(cex=1.2, fontface="bold"))
  }
  return(invisible())
}
```

generateFPHeatmaps
```{r}

# Input parameter is a chr vector of filepaths for the signal objects to make heatmaps from
# Part of ChIPPeakAnno package
# See for reference: https://www.rdocumentation.org/packages/ChIPpeakAnno/versions/3.6.5/topics/featureAlignedHeatmap

generateFPHeatmaps <- function(siglist){
  
  num <- length(siglist) # Get the number of inputs
  
  for (a in 1:num){
    
    gc() # clean up memory after each iteration
    sigs <- load(siglist[a]) # load the signals file from disk
    
    
    ## Make the filepath for saving the image
    
    
    
    svg(file =) # set the filepath for saving the svg figure
    
    ## Make the heatmap
    featureAlignedHeatmap(
                      # Calculated signals
                      sigs$signal,
                      # Pass the binding sites
                      # reCenterPeaks reset the center of the binding sites list
                      feature.gr=reCenterPeaks(sigs$bindingSites,
                                               width=200+width(sigs$bindingSites[1])),
                      # Column from the metadata for showing annotations on right side of map
                      annoMcols="score",
                      # What to use for sorting the rows
                      sortBy="score",
                      # Number of tiles to generate, set to width of the binding sites
                      n.tile=ncol(sigs$signal[[1]]))
    
    # Turn off the svg()
    dev.off()
    
  } # end for (a in 1:num){
} # end generateFPHeatmaps function

```

chromHeatmap
```{r}
#Reference: https://cran.r-project.org/web/packages/chromoMap/vignettes/chromoMap.html#installation
#This script will plot ATACseq aligned reads as a heatmap across visual representations of the chromosomes
#Input data must be in dataframe format with following columns:
#name - (type character) names of the elements for mapping, eg. gene names like "TP53"" or "NANOG"
#chrom - (type character) the chromosome name for the gene. It should be provided in format as "chr1","chr2","chrX",or "chrMT". Incorrect format can produce errors
#start - (type numeric) - the starting position of the element
#Heatmaps require these additional columns:
#data - (type numeric or integer) the primary data e.g. counts
#secondData - (type) secondary data for heatmap-double.

# Create a dataframe for H508 gene counts that can be used by chromoMap
bamfile <- "/home/rstudio2/atac/h508/bam/h508_all_dedup.bam" # input bamfile
dataset <- "H508" # name of dataset
edb <- EnsDb.Hsapiens.v86 # get the gene database
g <- genes(edb) # extract the genes
g <- keepStandardChromosomes(g, pruning.mode="coarse") # subset to only the standard chromosomes
num <- length(g) # get number of items
g@elementMetadata$id <- g@elementMetadata@listData[["symbol"]] # this metadata column is required to make the annot object
annot_gene <- createAnnotationFile(g) # create annotation file
# count the number of alignments in each gene
counts_gene <- featureCounts(
                        files=bamfile,
                        isPairedEnd=TRUE,
                        nthreads=8,
                        annot.ext=annot_gene)
h508_gene_atac_counts <- data.frame(
  name = counts_gene[["annotation"]][["GeneID"]],
  chrom = paste0("chr",counts_gene[["annotation"]][["Chr"]]),
  start = counts_gene[["annotation"]][["Start"]],
  data = counts_gene[["counts"]])
colnames(h508_gene_atac_counts)[colnames(h508_gene_atac_counts)=="X.home.rstudio2.atac.h508.bam.h508_all_dedup.bam"] <- "data" # rename the data column
h508_gene_atac_counts <- subset(h508_gene_atac_counts, !grepl(";", h508_gene_atac_counts$chrom)) # remove any entries that have more than one value in the chrom column (by matching to the ;)
row.names(h508_gene_atac_counts) <- NULL # drop the rownames to revert to index
rm(annot_gene, counts_gene, edb, g, bamfile, dataset, num) # cleanup the workspace


# Make the plots
# Annotation plots
chromoMap(h508_gene_atac_counts,type = "annotation") # show annotations of all 
chromoMap(h508_gene_atac_counts, type ="heatmap-single", HeatColRange = c("blue","white","red"))

# Annotation map of gene with at least 1 insertion, save to file
notzero <- subset(h508_gene_atac_counts, !grepl("0", h508_gene_atac_counts$data)) # remove entries with 0 counts
nz_anno_map <- chromoMap(notzero,type = "annotation") # show annotations of genes with at least 1 count
chromoMapToHTML(nz_anno_map,
                title = "ATACseq H508 WT Annotations",
                file = "ATACseq_H508_WT_01_Anno.html",
                dir = "C:/Users/Jordan/Desktop",
                desc = "Annotated set of genes having at least one Tn5 insertion in WT H508")


# Signal heatmap, save to file
h508_gene_atac_counts_map <- chromoMap(h508_gene_atac_counts, type = "heatmap-single", HeatColRange = c("blue", "white", "red")) 
chromoMapToHTML(h508_gene_atac_counts_map,
                title = "ATACseq H508 WT Heatmap",
                file = "ATACseq_H508_WT_01_Heat.html",
                dir = "C:/Users/Jordan/Desktop",
                desc = "Heatmap of Tn5 insertion in WT H508")




# Customizing the plot parameters
chromoMap(pancandata$data1,type = "annotation",dim = c(450,400)) # to resize
chromoMap(pancandata$data2,type = "heatmap-double",align = "vertical") # change orientation
chromoMap(pancandata$data1,chCol = "blue",chBorder = "blue") # change colors
chromoMap(pancandata$data1,chCol = "white",chBorder = "green") # change border style
chromoMap(pancandata$data1,annoColor = "pink") # change annotation color
chromoMap(pancandata$data1,textCol = "green") # change text color
chromoMap(pancandata$data1,bgBorder  = "#FF5733") # border
chromoMap(pancandata$data2,type="heatmap-double",bgCol  = "black") # background color
# Changing heat map colors
chromoMap(pancandata$data2,type="heatmap-double",HeatColRange = c("red","yellow","green")) # three color values are: minimum, medium, maximum values

## Saving plots to an HTML file
#use a variable to store your chromoMap
chmap = chromoMap(h508_gene_atac_counts,type = "heatmap-single", HeatColRange = c("red","yellow","green"))
#pass this to the function
chromoMapToHTML(chmap,file = "myfile.html",dir = "C:/Users/Jordan/Desktop")
#pass a title 
chromoMapToHTML(chmap,title = "Expression profile Comparison in normal vs tumor",file = "myfile.html",dir = "C:/Users/Jordan/Desktop")
#pass a description
my_desc = "you can write a paragraph to describe your plot"
chromoMapToHTML(chmap,title = "Expression profile Comparison in normal vs tumor",description = my_desc)
#open document after save
chromoMapToHTML(chmap,title = "Expression profile Comparison in normal vs tumor",description = my_desc,openAfterSave = TRUE)
```


** Run **
Running the code
```{r echo = FALSE}

runPipeline(dir_list, gene_info, reference_parameters, options_list)

```

Run a single footprint
```{r}

bampath <- "/home/rstudio2/atac/h508/bam/h508_all_dedup.bam"
baipath <- "/home/rstudio2/atac/h508/bam/h508_all_dedup.bam.bai"
motif_score <- "90%"
upstream <- 100
downstream <- 100
scope <- paste0("chr", c(1:22, "X", "Y"))
genome <- Hsapiens


symbol <- "TCF7"

organism_rows = grep('Hsapiens', values(MotifDb)$organism, ignore.case = TRUE)
gene_symbol_rows = grep(symbol, values(MotifDb)$geneSymbol, ignore.case = TRUE)
human_gene_rows = intersect(gene_symbol_rows, organism_rows)
gene_motifs <- as.list(MotifDb[human_gene_rows])
unique_gene_motifs <- unique(gene_motifs)

PWM <- unique_gene_motifs[[1]]
  
savefile <- "/home/rstudio2/atac/h508/graphs/tcf7_motif1.png"
png(filename = savefile)
    
    # generate signal
    signal <- factorFootprints(
                            # bam file input
                            bamfiles = bampath,
                            # bai index input
                            index = baipath,
                            # PWM input
                            pfm = PWM,
                            # reference genome
                            genome = genome,
                            # minimum motif matching score
                            min.score = motif_score,
                            # scope of analysis
                            seqlev = scope,
                            # bp upstream of motif to analyze
                            upstream = upstream,
                            # bp downstream of motif to analyze
                            downstream = downstream
                            )
    # turn off, important
    dev.off()


```

Make a single heatmap (ChipPeakAnno) library
```{r}

featureAlignedHeatmap(signal$signal, 
                      feature.gr=reCenterPeaks(signal$bindingSites,
                                               width=200+width(signal$bindingSites[1])), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=ncol(signal$signal[[1]]))

```





Step 1 : load the signals object
```{r}

# load the signals object from disk
#load("~/atac/h508/wt01/sigs/MNX1_motif1_wg_signals.RData")

## the R function apropro() can be used to find objects in the workspace by pattern matching to their name
name <- as.character(apropos("signals")[1])
wgsignals <- get(name)
# remove original
command <- paste0("rm(",name,")")
eval(parse(text = command))
rm(command,name)

# get the number of sites in the whole set
total_sites <- nrow(wgsignals[["signal"]][["+"]])

## sum up the signals
## NOTE - preserve the row names = genomic coordinates
plus <- wgsignals[["signal"]][["+"]]
minus <-  wgsignals[["signal"]][["-"]]
# combine the plus and minus strand signals
total_bp <- length(plus[1,])
combined <- matrix(data=NA,nrow=total_sites,ncol=total_bp)
# combine the signals
for (i in 1:total_sites){combined[i,] <- plus[i,] + minus[i,]}
# xfer row names
rownames(combined) <- rownames(plus)
# cleanup plus and minus
rm(plus,minus)
## get the motif width
motif_width <- total_bp - 200

## for each site, calculate the total signal and motif signal
signal_totals <- c() # total signal
motifsignal_totals <- c() # total signal in the motif
for (i in 1:total_sites){
  signal_totals[i] <- sum(combined[i,])
  motifsignal_totals[i] <- sum(combined[i,100:(100+motif_width)])}

## plot histograms of log10 transformed total signal data
logtot <- log10(signal_totals)
hist(logtot, main = "log10 total site signal")
logmot <- log10(motifsignal_totals)
hist(logmot, main = "log10 total binding motif signal")
rm(logtot,logmot)

## perform quantile analysis and get top 10%
# retrieve the specified quantiles from the total signals
quantiles <- quantile(signal_totals, probs = c(0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1))
# retrieve the indices of the sites in the top 10% of total signal
topten_ind <- which(signal_totals > quantiles[10])
# subset the sites data
topten_sites <- combined[topten_ind,]
# xfer the rownames
rownames(topten_sites) <- rownames(combined[topten_ind,])
# reset the number of inputs
topten_numsites <- nrow(topten_sites)

## recalculate total signal at each site
topten_signal_totals <- signal_totals[topten_ind] # total signal
topten_motifsignal_totals <- motifsignal_totals[topten_ind] # total signal in the motif
# plot log10 histograms
hist(log10(topten_signal_totals))
hist(log10(topten_motifsignal_totals))


## get all the unique values for total signal in the threshold passing sites
## this will be used to compute the null models
unique_signals <- unique(topten_signal_totals)

## generate the set of null models
null_sim <- list()
num <- length(unique_signals)
null_mean <- c()
for (i in 1:num){
  n <- 1000
  t <- unique_signals[i]
  s <- total_bp
  m <- motif_width
  null_sim[[i]] <- generateNullFP(n,t,s,m)
  null_mean[i] <- mean(null_sim[[i]])}

hist(null_mean)
hist(null_sim[[1]])

# generate a density plot of given motif signal means
d <- density(null_sim[[1]], adjust=1, from=0)
    # make the plot
    # main can be specified to make a chart title
    # make the title string
    title <- paste0("Motif signal means", "\n", "n = ", n, ", input signal = ", t, ", motif size = ", m)
    plot(d, main=title)
    
    
## Perform a one-tailed t-test to generate a p-value for each observed motif site
ttest <- list() # list to store the results of the t-tests
pvalue <- c() # vector to store the p-values
tvalue <- c() # vector to store the t-value

for (i in 1:topten_numsites){
  current <- c(topten_sites[i,])
  signal <- c(sum(current))
  # retrieve the appropriate null model
  nullmodel <- null_sim[[which(unique_signals==signal)]]
  # do the t-test
  ttest[[i]] <- t.test(current[100:116], mu=mean(nullmodel), alternative="less", conf.level = 0.95)
  pvalue[i] <- ttest[[i]][["p.value"]]
  tvalue[i] <- ttest[[i]][["statistic"]][["t"]]} 

# get the indices of the sites that are lower than p = 0.05
ppass_ind <- which(pvalue < 0.05)
pvalue_pass <- pvalue[ppass_ind]

# bonferroni correction
bf_ppass_ind <- which(pvalue < (0.05/topten_numsites))
bf_pvalue_pass <- pvalue[bf_ppass_ind]

# benjamin-hochberg correction
# because bonferroni is much more strict, and BH weights the strictness based on the rank of the p-value
bh_pvalues <- p.adjust(pvalue, method="BH")
bh_pass_ind <- (which(bh_pvalues<0.05))

# make histograms
# use xlim to control x axis
hist(pvalue, breaks=20, col="blue", main="p-values")
hist(pvalue_pass)
hist(bf_pvalue_pass)
hist(bh_pass_ind)

```

Step 2 : Find overlaps with the ARACNe network
```{r}
# load the regulons
load("~/atac/coad_regulons.RData")

## choose the correct MR
regulon <- coad_regulons$cdx2

## subset the top10 sites signals to only those that pass the p-value cutoffs
pvalue_pass_signals <- topten_sites[ppass_ind,] # raw p-value
bf_pass_signals <- topten_sites[bf_ppass_ind,] # bf corrected
bh_pass_signals <- topten_sites[bh_pass_ind,] # bh corrected

## match the raw p-value passing sites against ARACNE regulon
# get the rownames from the passed sites
rnames <- rownames(pvalue_pass_signals)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_pvalue_pass <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))


## make Granges for bonferroni corrected
# get the rownames from the passed sites
rnames <- rownames(bf_pass_signals)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_bf_pass <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))


## make Granges for BH correction
# get the rownames from the passed sites
rnames <- rownames(bh_pass_signals)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_bh_pass <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))

## make Granges for the whole topten percent population
# get the rownames from the passed sites
rnames <- rownames(topten_sites)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_topten <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))


## make Granges for the entire sites population
# get the rownames from the passed sites
rnames <- rownames(combined)
# number of names
num_names <- length(rnames)
# declare vectors to hold matches
chr_match <- c()
start_match <- c()
end_match <- c()
# use regex to parse the names into ranges
for (i in 1:num_names){
  # get current range
  cur <- rnames[i]
  # chr
  reg_chr <- regexpr("(chr\\d|chrX|chrY)", cur)
  chr_tmp <- regmatches(cur, reg_chr)
  # use gsub to remove the "chr"
  #chr_tmp <- gsub("chr", "", chr_tmp)
  chr_match[i] <- chr_tmp
  # start 
  reg_start <- regexpr(":(\\d*)", cur)
  start_tmp <- regmatches(cur, reg_start)
  # use gsub to remove the :
  start_tmp <- gsub("\\:", "", start_tmp)
  start_match[i] <- start_tmp
  # end 
  reg_end <- regexpr("-(\\d*)", cur)
  end_tmp <- regmatches(cur, reg_end)
  # use gsub to remove the -
  end_tmp <- gsub("\\-", "", end_tmp)
  end_match[i] <- end_tmp}
## Make a GRanges object with the ranges from the p-value passed sites
gr_allsites <- GRanges(
                    seqnames = chr_match,
                    ranges = IRanges(start = as.numeric(start_match), end = as.numeric(end_match)),
                    strand = c(rep("+", times = num_names)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = num_names)))


## Make a Granges for the ARACNe network, set to 2000 bp upstream of genes
#### Copy info from ensembl database to make GRanges object ####
# copy the database and gene info
edb <- EnsDb.Hsapiens.v86
g <- genes(edb)
rm(edb)
# subset to only the standard chromosomes
g <- keepStandardChromosomes(g, pruning.mode="coarse")
#### end ####

# get the list of regulon targets for current regulon
# these are in ENTREZ format
regulon_targets <- regulon[,2]
#### Subset the granges object for specific targets ####
regulon_gr <- c(which(g@elementMetadata@listData[["entrezid"]] %in% regulon_targets))
regulon_gr <- g[regulon_gr]
## modify the start ranges to include 2000 bp upstream region of each gene
for (a in 1:length(regulon_gr)){
  ### change positive strand entries
  if (regulon_gr[a]@strand@values == "+"){
    ### 2000 bp upstream
    regulon_gr[a]@ranges@start <- as.integer(regulon_gr[a]@ranges@start - 2000)
    regulon_gr[a]@ranges@width <- as.integer(regulon_gr[a]@ranges@width + 2000)}
  ### change negative strand entries
  if (regulon_gr[a]@strand@values == "-"){
    ### 2000 bp upstream
    regulon_gr[a]@ranges@width <- as.integer(regulon_gr[a]@ranges@width + 2000)}}

## Use repitools to convert the GRanges to a dataframe
x <- annoGR2DF(regulon_gr)
nchr <- c(paste0("chr",x[,1]))
nstart <- c(x[,2])
nend <- c(x[,3])
le <- length(nchr)
# make the granges
gr_regulon <- GRanges(
                    seqnames = nchr,
                    ranges = IRanges(start = as.numeric(nstart), end = as.numeric(nend)),
                    strand = c(rep("+", times = le)),
                    seqinfo = Seqinfo(genome="hg38"),
                    score = c(rep(1, times = le)))

## calculate the overlaps
overlaps <- matrix(data=NA,ncol=3,nrow=5)
colnames(overlaps) <- c("overlaps","total sites","percent")
rownames(overlaps) <- c("pvalue","bf_corrected","bh_corrected","topten","all")
## transfer to matrix
overlaps[1,1] <- length(findOverlaps(gr_pvalue_pass, gr_regulon, ignore.strand=TRUE))
overlaps[2,1] <- length(findOverlaps(gr_bf_pass, gr_regulon, ignore.strand=TRUE))
overlaps[3,1] <- length(findOverlaps(gr_bh_pass, gr_regulon, ignore.strand=TRUE))
overlaps[4,1] <- length(findOverlaps(gr_topten, gr_regulon, ignore.strand=TRUE))
overlaps[5,1] <- length(findOverlaps(gr_allsites, gr_regulon, ignore.strand=TRUE))
# total sites
overlaps[1,2] <- length(gr_pvalue_pass)
overlaps[2,2] <- length(gr_bf_pass)
overlaps[3,2] <- length(gr_bh_pass)
overlaps[4,2] <- length(gr_topten)
overlaps[5,2] <- length(gr_allsites)
# percents
overlaps[1,3] <- (overlaps[1,1]/overlaps[1,2])*100
overlaps[2,3] <- (overlaps[2,1]/overlaps[2,2])*100
overlaps[3,3] <- (overlaps[3,1]/overlaps[3,2])*100
overlaps[4,3] <- (overlaps[4,1]/overlaps[4,2])*100
overlaps[5,3] <- (overlaps[5,1]/overlaps[5,2])*100

```

Step 3 : Generate the new FP graphs and heatmaps
```{r}

## Subset the wg signals object bindingSites
## make profile function only requires binding sites and PWM as input
topten_bindingsites <- wgsignals[["bindingSites"]][topten_ind]
pvalue_pass_bindingsites <- topten_bindingsites[ppass_ind]
bf_pass_bindingsites <- topten_bindingsites[bf_ppass_ind]
bh_pass_bindingsites <- topten_bindingsites[bh_pass_ind]

## params
motif_score <- "90%" # Minimum PWM matching score to consider a locus a hit, expressed as percentage
scope <- paste0("chr", c(1:22, "X", "Y")) # Where to look in the genome, default is paste0("chr", c(1:22, "X", "Y"))
genome <- Hsapiens
bampath <- "/home/ubuntu1/atac/h508/wt01/bam/h508_all_dedup.bam"
baipath <- "/home/ubuntu1/atac/h508/wt01/bam/h508_all_dedup.bam.bai"
upstream <- 100
downstream <- 100

PWM <- getMotifPWM("MNX1")
PWM <- PWM[[1]]

# generate the profiles for all objects
topten_profile <- makeProfile(topten_bindingsites, PWM, type="normal")
pvalue_profile <- makeProfile(pvalue_pass_bindingsites, PWM, type="normal")
bf_profile <- makeProfile(bf_pass_bindingsites, PWM, type="normal")
bh_profile <- makeProfile(bh_pass_bindingsites, PWM, type="normal")

```

call plotFootprints function with profile parameters from makeProfile
```{r}
# Template
# plotFootprints(Profile, Mlen = 0, xlab = "Dist. to motif (bp)", ylab = "Cut-site probability", legTitle, xlim, ylim, newpage = TRUE, motif, segmentation)

    savepath_fp <- "/home/ubuntu1/atac/mnx1_motif1_h508_bh_correction.svg"

    ## FP graph
    PWMin <- pwm2pfm(PWM)
    #
    svg(file = savepath_fp) # set the filepath for saving the svg figure
    ATACseqQC:::plotFootprints(bh_profile$Profile,
                               Mlen=motif_width, motif=PWMin)
    dev.off()
    
    
    ## Subset the wg signals object signals (for making FP graphs)
    ## make profile function only requires binding sites and PWM as input
    plus <- wgsignals[["signal"]][["+"]]
    minus <- wgsignals[["signal"]][["-"]]
    plus <- plus[topten_ind,]
    minus <- minus[topten_ind,]
    plus <- plus[ppass_ind,]
    minus <- minus[ppass_ind,]
    
    pvalue_pass_signals <- list()
    pvalue_pass_signals[["signal"]]$"+" <- plus
    pvalue_pass_signals[["signal"]]$"-" <- minus
    pvalue_pass_signals[["bindingSites"]] <- pvalue_pass_bindingsites
    #topten_signals <- wgsignals[["signals"]][["+"]][[topten_ind,1:208]]
    #pvalue_pass_bindingsites <- topten_bindingsites[ppass_ind]
    #bf_pass_bindingsites <- topten_bindingsites[bf_ppass_ind]
    #bh_pass_bindingsites <- topten_bindingsites[bh_pass_ind]
    
    ## Heatmap graph
    savepath_heatmap <- "/home/ubuntu1/atac/cdx2_heatmap_pvalue.svg"
    svg(file = savepath_heatmap)
    
    featureAlignedHeatmap(pvalue_pass_signals$signal, 
                      feature.gr=reCenterPeaks(pvalue_pass_signals$bindingSites,
                                               width=200+width(pvalue_pass_signals$bindingSites[1])), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=ncol(pvalue_pass_signals$signal[[1]]))
    
    dev.off()
    
    sigs <- wgsignals
    
    featureAlignedHeatmap(sigs$signal, 
                      feature.gr=reCenterPeaks(gr,
                                               width=8), 
                      annoMcols="score",
                      sortBy="score",
                      n.tile=8)
    
   



```



