---
title: "generateFootprint"
author: "Jordan S. Kesner"
date: "January 24, 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

My personal code used to generate ATAC-seq footprints
Written because the ATAC-seq QC package is terrible at it and sucks up RAM for no reason
This code will generate the footprints based on precomputed counts matrices from bam files that show
the number of insertions at each bp position in the genome

Pseudocode:
 1) load sites object and use it to calculate wg signal
 2) Find total signal at every site
 3) Take top 10% sites
 4) Find all unique values for total signal
 5) Generate a null model for each unique total signal
 6) Perform t-test and generate p-values
 7) Get bonferroni corrected p-value passing sites
 8) Subset binding sites and regenerate profile
 9) Plot footprint and save profiles

Install and load libraries
```{r}
#### Library installs
#source("https://bioconductor.org/biocLite.R")
#biocLite("ATACseqQC", suppressUpdates = TRUE)
#biocLite("MotifDb", suppressUpdates=TRUE)
#biocLite("BSgenome.Hsapiens.UCSC.hg38", suppressUpdates = TRUE)
#### Library installs
#source("https://bioconductor.org/biocLite.R")
#biocLite("ATACseqQC", suppressUpdates = TRUE)
#biocLite("MotifDb", suppressUpdates=TRUE)
#biocLite("BSgenome.Hsapiens.UCSC.hg38", suppressUpdates = TRUE)
#biocLite("ChIPpeakAnno", suppressUpdates = TRUE)
#biocLite("Rsamtools", suppressUpdates = TRUE)
#### Library loads
gc()
cat("Loading libraries...", "\n")
suppressMessages(library(ATACseqQC))
suppressMessages(library(MotifDb))
suppressMessages(library(BSgenome.Hsapiens.UCSC.hg38))
suppressMessages(library(Rsamtools))
suppressMessages(library(GenomicAlignments))
suppressMessages(library(ChIPpeakAnno))
suppressMessages(library(GenomicAlignments))
suppressMessages(library(ChIPpeakAnno))
```

Completed functions
```{r}

##
pwm2pfm <- function(pfm, name="motif"){
  if(!all(round(colSums(pfm), digits=4)==1)){
    return(NULL)
  }
  new("pfm", mat=as.matrix(pfm), name=name)
}

##
plotFootprints <- function (Profile, Mlen = 0, xlab = "Dist. to motif (bp)", ylab = "Cut-site probability",                  legTitle, xlim, ylim, newpage = TRUE, motif, segmentation){
  stopifnot(is(motif, "pfm"))
  if(newpage) grid.newpage()
  
  S <- length(Profile)
  W <- ((S/2) - Mlen)/2
  vp <- plotViewport(margins=c(5.1, 5.1, 4.1, 2.1), name="plotRegion")
  pushViewport(vp)
  if(missing(xlim)){
    xlim <- c(0, S/2+1)
  }
  if(missing(ylim)){
    ylim <- c(0, max(Profile) * 1.12)
  }
  vp1 <- viewport(y=.4, height=.8,
                  xscale=xlim,
                  yscale=ylim,
                  name="footprints")
  pushViewport(vp1)
  grid.lines(x=1:(S/2),
             y=Profile[1:(S/2)],
             default.units="native",
             gp=gpar(lwd = 2, col = "darkblue"))
  grid.lines(x=1:(S/2),
             y=Profile[(S/2 + 1):S],
             default.units="native",
             gp=gpar(lwd = 2, col = "darkred"))
  if(!missing(segmentation)){
    if(length(segmentation)==4){
      ## plot the guide line for the segmentation
      grid.segments(x0=c(0, segmentation[1], W, W+Mlen, S/2-segmentation[1]),
                    x1=c(segmentation[1], W, W+Mlen, S/2-segmentation[1], S/2),
                    y0=c(segmentation[2], segmentation[3], segmentation[4], segmentation[3], segmentation[2]),
                    y1=c(segmentation[2], segmentation[3], segmentation[4], segmentation[3], segmentation[2]),
                    default.units = "native",
                    gp=gpar(lwd =2, col = "red", lty = 2))
    }
  }
  grid.xaxis(at = c(seq(1, W, length.out = 3),
                    W + seq(1, Mlen),
                    W + Mlen + seq(1, W, length.out = 3)),
             label = c(-(W + 1 - seq(1, W + 1, length.out = 3)),
                       rep("", Mlen),
                       seq(0, W, len = 3)))
  grid.yaxis()
  grid.lines(x=c(W, W, 0), y=c(0, max(Profile), ylim[2]),
             default.units="native", gp=gpar(lty=2))
  grid.lines(x=c(W + Mlen + 1, W + Mlen + 1, S/2),
             y=c(0, max(Profile), ylim[2]),
             default.units="native", gp=gpar(lty=2))
  upViewport()
  vp2 <- viewport(y=.9, height=.2,
                  xscale=c(0, S/2+1),
                  name="motif")
  pushViewport(vp2)
  motifStack::plotMotifLogoA(motif)
  upViewport()
  upViewport()
  grid.text(xlab, y=unit(1, 'lines'))
  grid.text(ylab, x=unit(1, 'line'), rot = 90)
  if(missing(legTitle)){
    legvp <- viewport(x=unit(1, "npc")-convertX(unit(1, "lines"), unitTo="npc"),
                      y=unit(1, "npc")-convertY(unit(1, "lines"), unitTo="npc"),
                      width=convertX(unit(14, "lines"), unitTo="npc"),
                      height=convertY(unit(3, "lines"), unitTo="npc"),
                      just=c("right", "top"), name="legendWraper")
    pushViewport(legvp)
    grid.legend(labels=c("For. strand", "Rev. strand"),
                gp=gpar(lwd=2, lty=1, col=c("darkblue", "darkred")))
    upViewport()
  } else {
    grid.text(legTitle,
              y=unit(1, "npc")-convertY(unit(1, "lines"), unitTo="npc"),
              gp=gpar(cex=1.2, fontface="bold"))
  }
  return(invisible())
}

##
generateNullFP <- function(n, t, s, m){
  #This script will be used to generate indiviudal null models at predicted motif binding sites across the genome when scanning for TF footprinting from ATAC-seq data. To generate these null models, the current model will need to:
  #- Consider the total signal (number of insertions) at each specific ~200 bp locus
  #- Use the actul underlying reference sequence of that ~200 bp stretch from the hg38 reference genome
  #- Use published or experimentally derived models of Tn5 sequence specific insertion bias
  #- For each locus, build a probablistic model of insertion site distributions based on the underlying sequence and Tn5 insertion bias
  #- Generate the null model graph by weighted random residstribution of the total observed signal at that site
  #- Importantly, the null model must be generated separately for the plus and minus strand, it can then be combined and compared to the combined signal from the reference observed signal at that sequence
  #These null models can then be used for a site-by-site comparison of the null model against the observed data to accept or reject the null hypothesis
  
  # declare vector of size n to store average motif signal values
  averages <- c()
  
  # generate the null models and calculate motif averages
  for (a in 1:n){
    
    # declare the null vector
    null <- c(1:(s))
    
    # randomly distribute the total signal
    # size = the number of values to distribute
    # prob = probability of each site
    # length = length of the generated vector
    null <- c(as.vector(rmultinom(1, size=t, prob=rep(1, length(null)))))
    
    # calculate the average signal in the motif region
    b <- (s - 100 - m) # start of motif
    c <- (s - 100) # end of motif
    avg <- sum(null[b:c])
    avg <- (avg/m)
    
    # store the values
    averages[a] <- avg
    
    ### plotting
    # make the density plot
    # generate the density distribution
    # adjust can be modified to adjust the kernel estimation bandwidth
    #d <- density(averages, adjust=1, from=0)
    # make the plot
    # main can be specified to make a chart title
    # make the title string
    #title <- paste0("Motif signal means", "\n", "n = ", n, ", input signal = ", t, ", motif size = ", m)
    #plot(d, main=title)
    ## check for uniform distribution with QQ plot
    #qqplot(averages, runif(1000))
    #abline(0,1)
    
  } # end for (a in 1:n)
  return(averages)
} # end generateNullFP function




```

Snakemake variables
```{r}

#### Snakemake variables
cat("Loading snakemake variables...", "\n")
bampath <- snakemake@input[[1]]
baipath <- snakemake@input[[2]]
sitesfile <- snakemake@input[[3]]
out_filepath <- snakemake@output[[1]]
sample_name <- snakemake@wildcards[["sample"]]
gene_name <- snakemake@wildcards[["gene"]]
cat("Sample name:", sample_name, "\n", "Gene name:", gene_name, "\n")

```


```{r}

#### Load workspace
cat("Loading workspace...", "\n")
load(sitesfile)
num_motif <- length(bindingSites)
rm(bindingSites, genome, PWM, PWMlist, sites, temp, b, gene, num_pwm, outpath, getMotifPWM)
gc()

#### Parameters
cat("Setting input parameters...", "\n")
motif_score <- "95%"
upstream <- 100
downstream <- 100
scope <- paste0("chr", c(1:22, "X", "Y"))
genome <- Hsapiens
```



Setup
```{r}

## Count matrices
chr21_counts = read.table("C:\\Users\\jsk33\\Documents\\atac\\snu61\\wt01\\counts\\counts_chr21.txt", 
               sep=" ", 
               col.names=c("chr", "5", "3"), 
               fill=FALSE, 
               strip.white=TRUE)

# in the above matrix, the 5 column is the 5' insertion site and the 3 column is the leftmost position of the mate
# for now, ignore the 3' sites and only use 5'
# count up the insertions at each base position
# this represents all the non-0 positions
uq <- unique(chr21_counts[,2])
# the number of bp with at least 1 insertion
num_uq <- length(uq)
# get the most common values in a sorted vector
common <- sort(table(chr21_counts[,2]))

# aggregate the insertions
ins <- matrix(data = NA, nrow = num_uq, ncol = 2)
## count them up
for (a in 1:num_uq){
  cat("Processing site ", a, "of ", num_uq, "\n")
  ins[a,1] <- uq[a]
  ins[a,2] <- length(which(chr21_counts[,2] == uq[a]))}


## Genomic sites
load("C:\\Users\\jsk33\\Documents\\atac\\coad_mr_sites\\CDX2.sites.Rdata")
sites <- data.frame(bindingSites[[1]][["sites"]])
rm(bindingSites, PWMlist, temp, b, num_pwm, outpath, genome)
motif_size <- length(PWM[1,])

# subset
sites <- sites[which(sites[,1] == "chr21"),]
# number of sites under consideration
num_sites <- length(sites[,1])
# declare the matrix
sites_signals <- matrix(data = 0, ncol = (motif_size+200), nrow = num_sites)
#
for (a in 1:num_sites){
  cat("site ", a, "of ", num_sites, "\n")
  start <- sites[a,2]-101
  end <- sites[a,3]+100
  width <- end-start
  #
  for (b in 1:width){
    
    # set current bp position on xsome
    pos <- (start+b-1)
    
    # 
    if (pos %in% uq == TRUE){
      sites_signals[a,b] <- ins[(which(ins[,1] == pos)),2]
      
    } # end if (pos %in% uq == TRUE)
  } # end for (b in 1:width)
} # end for (a in 1:num_sites)


## Calc cov constant
libSize <- length(chr21_counts[,1])
coverageSize <- length(uq)
libFactor <- libSize / coverageSize


## Make profile
Profile <- colMeans(sites_signals, na.rm = TRUE)/libFactor
Profile <- c(Profile, rev(Profile))

## Plot FP
PWMin <- pwm2pfm(PWM)
plotFootprints(Profile = Profile,
                           Mlen = motif_size,
                           motif = PWMin,
                           newpage = TRUE)
                           #segmentation = Profile.seg)



```






```{r}

#### Generate WG signals with binding sites object
for (a in 1:num_motif){ # An iterator for each unique motif for this gene
  
  # Set the filepath for the signal Rdata file
  signal_path <- paste0("coad_footprints/", sample_name, ".", gene_name, ".", "motif", a, ".Rdata")
  
  # Check if the file already exists, if it does, skip and move on
  if (file.exists(signal_path) == TRUE){
    cat("File already exists, skipping...", "\n")
    next
  } else {
  
  #
  cat("Retrieving stored binding sites...", "\n")
  load(sitesfile)
  PWM <- bindingSites[[a]][["PWM"]]
  sites <- bindingSites[[a]][["sites"]]
  rm(bindingSites, PWMlist, temp, b, gene, num_pwm, outpath, getMotifPWM)
  gc()
  
  #
  cat("Generating WG footprint signal", a, "of ", num_motif,  "\n")
  sites <- keepStandardChromosomes(sites, pruning.mode="coarse")
  sites <- keepSeqlevels(sites, scope, pruning.mode="coarse")

  # generate signal
  wgsignals <- factorFootprints(
    # bam file input
    bamfiles = bampath,
    # bai index input
    index = baipath,
    # PWM input
    pfm = PWM,
    # reference genome
    genome = genome,
    # minimum motif matching score
    min.score = motif_score,
    # scope of analysis
    seqlev = scope,
    # bp upstream of motif to analyze
    upstream = upstream,
    # bp downstream of motif to analyze
    downstream = downstream,
    # binding sites
    bindingSites = sites
  )
  
  # get the number of sites in the whole set
  total_sites <- nrow(wgsignals[["signal"]][["+"]])
  cat("Total sites found:", total_sites, "\n")
 
  ## sum up the signals
  ## NOTE - preserve the row names = genomic coordinates
  plus <- wgsignals[["signal"]][["+"]]
  minus <-  wgsignals[["signal"]][["-"]]
  # combine the plus and minus strand signals
  total_bp <- length(plus[1,])
  combined <- matrix(data=NA,nrow=total_sites,ncol=total_bp)
  # combine the signals
  for (i in 1:total_sites){combined[i,] <- plus[i,] + minus[i,]}
  # xfer row names
  rownames(combined) <- rownames(plus)
  # cleanup plus and minus
  rm(plus,minus)
  ## get the motif width
  motif_width <- total_bp - 200
  
  ## for each site, calculate the total signal and motif signal
  cat("Calculating signal at each site...", "\n")
  signal_totals <- c() # total signal
  motifsignal_totals <- c() # total signal in the motif
  for (i in 1:total_sites){
    signal_totals[i] <- sum(combined[i,])
    motifsignal_totals[i] <- sum(combined[i,100:(100+motif_width)])}
  
  ## perform quantile analysis and get top 10%
  # retrieve the specified quantiles from the total signals
  quantiles <- quantile(signal_totals, probs = c(0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1))
  # retrieve the indices of the sites in the top 10% of total signal
  topten_ind <- which(signal_totals > quantiles[10])
  # subset the sites data
  topten_sites <- combined[topten_ind,]
  # xfer the rownames
  rownames(topten_sites) <- rownames(combined[topten_ind,])
  # reset the number of inputs
  topten_numsites <- nrow(topten_sites)
  ## recalculate total signal at each site
  topten_signal_totals <- signal_totals[topten_ind] # total signal
  topten_motifsignal_totals <- motifsignal_totals[topten_ind] # total signal in the motif

  ## get all the unique values for total signal in the threshold passing sites
  ## this will be used to compute the null models
  unique_signals <- unique(topten_signal_totals)
  
  ## generate the set of null models
  ## Remember, you must store the null models for proper record keeping and reproducibility
  cat("Generating null models...", "\n")
  null_sim <- list()
  num <- length(unique_signals)
  null_mean <- c()
  for (i in 1:num){
    n <- 1000
    t <- unique_signals[i]
    s <- total_bp
    m <- motif_width
    null_sim[[i]] <- generateNullFP(n,t,s,m)
    null_mean[i] <- mean(null_sim[[i]])}
  
  ## Perform a one-tailed t-test to generate a p-value for each observed motif site
  ttest <- list() # list to store the results of the t-tests
  pvalue <- c() # vector to store the p-values
  tvalue <- c() # vector to store the t-value
  
  for (i in 1:topten_numsites){
    current <- c(topten_sites[i,])
    signal <- c(sum(current))
    # retrieve the appropriate null model
    nullmodel <- null_sim[[which(unique_signals==signal)]]
    # do the t-test
    ttest[[i]] <- t.test(current[100:116], mu=mean(nullmodel), alternative="less", conf.level = 0.95)
    pvalue[i] <- ttest[[i]][["p.value"]]
    tvalue[i] <- ttest[[i]][["statistic"]][["t"]]}
  
  # get the indices of the sites that are lower than p = 0.05
  ppass_ind <- which(pvalue < 0.05)
  pvalue_pass <- pvalue[ppass_ind]
  
  # bonferroni correction
  bf_ppass_ind <- which(pvalue < (0.05/topten_numsites))
  bf_pvalue_pass <- pvalue[bf_ppass_ind]
  
  ## Subset the wg signals object bindingSites
  ## make profile function only requires binding sites and PWM as input
  #pvalue_pass_bindingsites <- topten_bindingsites[ppass_ind]
  #bh_pass_bindingsites <- topten_bindingsites[bh_pass_ind]
  topten_bindingsites <- wgsignals[["bindingSites"]][topten_ind]
  bf_pass_bindingsites <- topten_bindingsites[bf_ppass_ind]
  
  # generate the profiles for all objects
  cat("Generating CENTIPEDE profile...", "\n")
  #topten_profile <- makeProfile(topten_bindingsites, PWM, type="normal")
  #pvalue_profile <- makeProfile(pvalue_pass_bindingsites, PWM, type="normal")
  bf_profile <- makeProfile(bf_pass_bindingsites, PWM, type="normal")
  #bh_profile <- makeProfile(bh_pass_bindingsites, PWM, type="normal")
  
  #
  svg_path <- paste0("coad_footprints/", sample_name, ".", gene_name, ".motif", a, ".svg")
  svg(file = svg_path) # set the filepath for saving the svg figure
  cat("Saving svg footprint image at path:", svg_path, "\n")
  
  ## FP graph
  PWMin <- pwm2pfm(PWM)
  cat("Plotting graph...", "\n")
  ATACseqQC:::plotFootprints(bf_profile$Profile,
                             Mlen=motif_width, motif=PWMin)
  dev.off()
  
  ##
  cat("Transferring data to FPdata object...", "\n")
  FPdata <- list()
  FPdata$motif <- a
  FPdata$PWM <- PWM
  FPdata$wg_bindingsites <- sites
  FPdata$wg_numsites <- total_sites
  FPdata$wg_signals <- wgsignals
  FPdata$bf_pass_bindingsites <- bf_pass_bindingsites
  FPdata$bf_pvalue_pass <- bf_pvalue_pass
  FPdata$bf_profile <- bf_profile
  FPdata$pvalue <- pvalue
  FPdata$tvalue <- tvalue
  FPdata$null_sim <- null_sim
  FPdata$wg_top10_signaltotals <- topten_signal_totals
  FPdata$wg_top10_motifsignal_totals <- topten_motifsignal_totals
  FPdata$wg_signaltotals <- signal_totals
  FPdata$wg_motifsignal_totals <- motifsignal_totals
  ##
  rm(PWM, sites, total_sites, wgsignals, bf_pass_bindingsites, bf_pvalue_pass, bf_profile, pvalue, tvalue, null_sim, topten_signal_totals, topten_motifsignal_totals, signal_totals, motifsignal_totals)
  cat("Saving signals data for gene", gene_name, "motif", a, "at path:", signal_path, "\n")
  save.image(file = signal_path)
  rm(FPdata)
  gc()
  }
}

############

#### Save
cat("Finalizing...\n")
file.create(file = out_filepath)

#### Cleanup workspace
cat("Cleaning workspace...", "\n")
rm(list=ls())
gc()


```







